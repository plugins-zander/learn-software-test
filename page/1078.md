# 面向对象测试

## 面向对象测试的基本概念

### 面向对象技术的特点及其对软件测试的影响

面向对象程序通常由一系列类组成，在类定义中封装了数据及作用在数据上的操作，数据和操作统称为特征。对象是类的实例。类和类之间按继承关系组成一个无环有向图结构，父类中定义了共享的公共特征，子类除继承父类中定义的所有特征外，还可以引入新的特征，也允许对继承的方法重新定义。面向对象语言提供的动态绑定机制将对象与方法动态地联系起来。面向对象程序的封装性、继承性、动态绑定等特性使程序具有较大的灵活性，给软件测试提出了新的要求，这使得面向对象软件的测试更加复杂。



#### 1、 类和对象对测试的影响

在面向对象系统中，系统的最小可测试单元不再是函数或过程，而是类和对象。类和对象封装了很多方法和属性，在很大程度上增加了系统聚合度，降低耦合度，提高了系统整体的可维护性；但却牺牲了单元测试容易性，增加了复杂性。	

基于状态单元测试方法，其基本思想是：将类和对象看作一台有限状态自动机，其状态由其属性来表征，其方法根据当前状态或外部发送过来的消息，作出相应的状态转换和输出信息。然后在此基础上，为有限状态自动机的每个状态设计相应的测试用例，对每个状态进行分而治之地测试，降低测试的复杂度。在面向对象设计时，往往将类和对象动态特性描述成有限状态自动机。因而，我们可以很容易地实现基于状态单元测试方法，即利用前期设计的有限状态自动机，为每个状态设计相应的测试用例。



> 例6-1用数组栈类的例子来说明。在数组栈类中主要含有方法Push、PoP和属性Top，其中属性Top用于指出栈顶元素在数组中的位置。数组栈的有限状态机如图6-1所示，此自动机包括正常、空和满三个状态，状态由属性Top来表征，例如ToP＝0表示空状态。在设计测试用例时，必须保证这些用例能够使得该类所有状态都得到遍历；同时在每个状态中还需要设计测试用例，激发非法操作(例如，在空状态，调用Pop操作)以及验证该类的健壮性。

![](https://img1.zlogs.net/20/20200117223103.png)

<center>数组栈的有限状态机</center>







#### 2、继承对测试的影响

​	面向对象的继承是允许在已有类（基类或父类）的基础上定义新类，新类称为派生类或子类。而派生出的子类可以继承父类的特性，同时还可以增加自己的功能和修改继承得到的功能。在继承关系中，子类不仅包含父类的所有成员，更重要是它复制了父类的接口。

​	面向对象程序设计语言提供这种机制给了程序员一定的灵活性，但给软件测试带来一定的影响，**即父类中的方法在子类环境下是否需要重新测试？**

例子

- 

  ![img](https://img1.zlogs.net/20/20200117223104.png)



#### 3、 封装和信息隐蔽对测试的影响

​	封装是将一组相关的概念聚集在一个单元内。面向对象的封装是将操作和属性包装在一个对象类型中，只能通过封装体提供的接口来访问和修改。

​	通常的解决的方法是**在类和对象上添加一个成员函数，**该函数用于读取(而不是修改)对象的状态信息。当测试时，用来考察对象的状态变化。但必须保证该函数在一定程度上的正确性。为了达到更好的测试效率，甚至可以添加能够捕获外部或内部发送过来的消息的成员函数，记录各消息的参数发送的时间。当测试完成后，可将这些成员函数删除，以便提高软件系统的运行速度。

> 增加一个成员函数，（不影响其正确性）--> 测试--> 去除成员函数



#### 4、多态性对测试的影响

​	多态性是面向对象方法的关键特性之一。可以根据发生消息的对象不同采取不同的处理方法，它使得系统在运行时能自动为给定的消息选择合适的实现代码。这给程序员提供了高度柔性、问题抽象性和易于维护性。但多态性所带来的不确定性，也使得传统测试实践中的**静态分析法遇到了不可逾越的障碍**。与此同时，还增加了系统运行中可能的执行路径，加大了测试用例的选取难度和数量，这种不确定性和骤然增加的路径组合给测试覆盖率的满足带来了挑战。多态性给软件测试带来的问题仍然是目前研究的重点及难点问题之一。

> 动态的无法用静态来搞，情况太多，目前未解决的问题





#### 5、 进一步讨论

​	在单元测试中，我们引入的基于状态单元测试方法有其致命的弱点，就是测试效率低。仍旧以数组栈为例，假设该数组栈栈空间为64KB，每一个数据项占一个字节，则将数组栈从空状态切换到满状态，必须调用PUSH()方法64×1024次。由于对象的信息隐蔽和封装性，无法直接修改对象属性。也就是说，若要测试在数组栈满状态下对象的特性，首先必须调用PUSH（)方法64×l024次，以便切换到满状态下，这样大大降低了测试的效率。同样，对于类中重新定义过的方法和某些继承下来的方法重新测试时，也存在状态切换低效率问题。

>  切换状态无法直接修改，因为封装性，只能一个个规规矩矩的加入

> 添加友元类来添加修改要切换状态的类



例6-3 我们定义一个测试类，该类在程序调试时刻，默认为其他类的友员类，可以读取和修改其他类的属性。在测试代码中，根据测试需要，可以插入修改和读取被测试类的属性。下面是测试类的接口定义：

```c++
typedef tagProperty_List      	//属性列表
{	 String Property_Name[]; 	//属性名称
String Property_Type[]; 	//属性类型
Void* Property——Ref[]; 	//属性引用地址
} Property_List;

```





## 面向对象测试模型

​	面向对象的开发模型，分为面向对象分析（OOA）、面向对象设计（OOD）、和面向对象编程（OOP）三个阶段。



​	将面向对象的软件测试分为：面向对象分析的测试（OOATest），面向对象设计的测试（OODTest），面向对象编程的测试（OOPTest）



![](https://img1.zlogs.net/20/20200117223105.png)

<center>面向对象测试模型</center>

OOA Test:面向对象的分析测试OOD Test:面向对象设计的测试OOP Test:面向对象编程的测试OO Unit Test:面向对象单元测试OO Intergrate Test:面向对象集成测试OO System Test:面向对象系统测试



## 面向对象的测试方法概述



### 面向对象的测试方法

​	将面向对象的测试分为三个层次：类的单元测试、类的集成测试和系统测试。 面向对象软件的测试分层如表6-1所示。



面向对象软件的测试层

| 传统测试 | 面向对象测试              |
| -------- | ------------------------- |
| 单元测试 | 类测试(方法测试 对象测试) |
| 集成测试 | 类的集成模块测试          |
| 系统测试 | 系统测试                  |



![](https://img1.zlogs.net/20/20200117223106.png)



在设计测试用例选择输入数据时，可以基于以下两个假设： 

(1)如果函数(程序)对某一类输入中的一个数据正确执行，对同类中的其他输入也能正确执行。

 (2)如果函数(程序)对某一复杂度的输入正确执行，对更高复杂度的输入也能正确执行。例如需要选择字符串作为输入时，基于本假设，就无须计较字符串的长度，除非字符串的长度是要求固定的，如IP地址字符串。





### 面向对象的测试相关概念

 1、测试特征

典型的测试特征有：（1） 控制依赖和数据依赖；（2） 状态转换、事务、规程、交互等；（3） 约束和断言，如因果关系、互斥关系、前后条件、不变式等；（4） 等价类、边界等。

2、测试用例

​	测试用例是被测对象对制定输入产生预期结果的表示。

4、测试层次结构	

​        层次测试级与测试复杂性分解的思想，是软件测试的基本模式。面向对象软件测试根据测试层次结构可以分为单元级、集成级到系统级的分层测试，测试集成的过程是一个基于可靠部件组装系统的过程。

5、测试步骤

对于面向对象的测试，测试人员一般要做以下步骤：（1）为类创建一个实例，即对象，为构造函数传递合适的参数； （2）通过参数传递调用对象的方法并获取结果； （3）检查对象的内部数据。



## 面向对象的单元测试（类测试）

（1）基于服务的测试：测试类中的每一个服务（即方法）；

> 测试类的方法

（2）基于对象的测试：因为类是一个抽象定义的、属性和操作的封装体，只有实例化后才能起作用，因此需要对类进行实例化测试，类实例化测试的实现是通过构造函数和析构函数来完成的；

> 类创建对象测试

（3）基于状态的测试：考察类的实例在某生命周期各个状态下的情况；

> 如数组栈的各个满不满状态

（4）基于响应状态测试：从类和对象的责任出发，以外界向对象发送特定的消息序列来测试对象。

> 发送消息看反应是否正确

在这里我们主要介绍基于服务的测试和基于状态的测试。

### 基于服务的测试

基于服务的类测试主要考察封装在类中的一个方法对数据进行的操作。Kung等人提出的块分支图（Block Branch Diagram，BBD）是一种比较好的类的服务测试模型。

![](https://img1.zlogs.net/20/20200117223107.png)、



基于服务的块分支图

服务f的BBD是一个五元组，可写为f=(Du，Dd，P，Fe，G)

其中：Du={di| di∈f 引用的全局数据或类数据}；

Dd={di| di∈f修改了全局数据或类数据}；

P={X1θ1，X2θ2，…，Xnθn，Xn+1θn+1∈f的参数表和函数返回值，θi为↓（表示输入）、↑（表示输出）、↓↑（表示输入/输出），若Xn+1缺省，则无返回值}；

Fe={Fi| Fi∈被f 调用的其他服务}；

G是一个有向图，叫块体，它是按照控制流图的思想修改f的程序流程图而来的，表示f的控制结构，f中的复合条件判断被分解，每个判断框只有单个的条件。



 BBD的获得方法有两种：

（1）采用逆向工程的方法，由源程序画出流程图构造出BBD图。

（2）是在软件的分析设计阶段构造出相应的BBD图。前一种方法可能因为源程序不正确而构造出错误的BBD图。后一种方法更可靠些。



> 例6-4 我们用C++设计一个矩形类Rectangle。要求如下：（1）该类中的私有变量存放Rectangle的长和宽，并且设置它们的默认值为1；（2）通过构造函数设置其长和宽，并确保长和宽值的范围为（0，50）；（3）并分别设置成员函数求周长Perimeter（）和求面积Aear（）。

```c++
其C++程序段如下：
Class Rectangle
{
Private:
	float width;
	float height;
Public:
	Rectangle(float w=1,float h=1){
		if (w>0 && w<50)	width =w;
		if (h>0 && h<50)	height =h;		}
	~Rectangl(){   }
	float Perimerter( )	{  return  (2*( width + height y));	}
	float Aear(  )	{  return (width * height);	}
}

```



> 对类Rectangly中构造函数Rectangle()的BBD图

![](https://img1.zlogs.net/20/20200117223108.png)



<center>类Rectangle中构造函数Rectangle（）的BBD图</center>

```
通过构造BBD图，采用基本路径测试的结构测试方法对类Rectangle中的构造函数Rectangle（）进行测式，查找语句覆盖和分支覆盖的错误。
具体步骤如下：
（1）绘制BBD图对应的控制流图。先将判断条件改为单个条件，如图6-5（a）所示，再变换为对应的流图，如图6-5（b）所示。
（2）确定基本路径集。根据前面介绍的算法得复杂度为：判断框数+1=4+1=5。
Path1:①-②-③-④-⑥-⑦-⑧-⑩
Path2:①-②-⑤-⑥-⑦-⑧-⑩
Path3:①-②-③-⑤-⑥-⑦-⑧-⑩
Path4: ①-②-③-④-⑥-⑨-⑩
Path5: ①-②-③-④-⑥-⑦-⑨-⑩

```



![](https://img1.zlogs.net/20/20200117223109.png)



类Rectangle构造函数Rectangle（）的控制图和流图

（3）设计测试用例。

类Rectangle构造函数Rectangle（）的测试用例

| ID    | 输入数据 | 输入数据 | 返回值 | 返回值 | 通过的路径 |
| ----- | -------- | -------- | ------ | ------ | ---------- |
|       | w        | h        | width  | heigth |            |
| Test1 | 10       | 20       | 10     | 20     | Path1      |
| Test2 | 0        | 20       | 1      | 20     | Path2      |
| Test3 | 60       | 20       | 1      | 20     | Path3      |
| Test4 | 10       | 0        | 10     | 1      | Path4      |
| Test5 | 10       | 60       | 10     | 1      | Path5      |



### 基于状态的测试

对象状态的测试是依赖对象状态的行为还不是控制结构或单个数据。所以状态测试的主要思想是考察类的实例在生命周期各个状态下的情况，以及外界向对象发送特定消息序列的方法来测试对象的响应状态。



通过构造OSD（Object State Diagram）模型来进行类的状态测试。

OSD模型是用于测试对象的动态行为的测试模型。对象状态图可以分为两种：

（1）原子对象状态图（AOSD）：表现的是一个类的数据成员的状态和状态的转换，它可用作类的数据成员的动态行为的测试模型。

（2）复合对象状态图（COSD）：表现的是对象的正交的不同部分之间的动态行为，它可以用来检验对象的状态和状态的转换。







#### 1、AOSD模型

AOSD中的转换是类的成员从源状态到目的状态的状态的改变。

AOSD=（S,σ，δ，q0,qf）。

其中：S是一个有限的状态集合；σ是一个有限的触发集合；δ是（S∪Sλ）×σ到S的映射，即转换函数。Sλ表示对象生成的以前的存在的状态。q0是S的初始状态集合，qf是S的终止状态集合。ti是相关条件或函数调用。





![](https://img1.zlogs.net/20/20200117223110.png)



<center>原子对象状态图</center>

与传统的有限状态比较，有三点扩展：①可能有多于一个的初始状态；②一个转换可以是有条件的也可以是无条件的；③有一些转换是交互转换，即一个AOSD中的交互转换可以激发另一个AOSD中的转换。



#### 2、COSD模型

在OSD中相应地用三部分来表示对象的动态行为。

（1）定义的部分：表示在该类中定义的数据成员的状态及转换，由对象的状态定义的数据成员的状态图组成。

（2）聚集的部分：表示对象中的成员对象的状态行为，由构成复杂对象的成员对象的状态图组成。

（3）继承的部分：表示继承的数据成员的状态及转换，由派生出复杂对象的基类的对象的状态图组成。一个复合的OSD记为COSD。



说明：一个AOSD的组合是一个COSD；一个AOSD和COSD组合是一个COSD。



![](https://img1.zlogs.net/20/20200117223111.png)

COSD图



对一个自动售货机，假设每次用一元的硬币投入到硬币盒，当收到两个一元币时允许出售货物。包括一些简单的功能，增加一个硬币，返回现有的硬币，将硬币复位到初始状态，以及出售。用三个变量来表示数据：totalQtrs表示硬币总数，CurQtrs表示现在硬币数目，allowVend表示允许售卖。硬币盒的C++源程序代码如下：

```c++
Class CcoinBox
{
	unsigned totalQtrs;  //硬币总数
	unsigned CurQtrs;   //现在硬币数
	unsigned allowVend; //允许售卖
Public:
	CcoinBox( ) {Reset( );}
	void AddQtr( );		//增加一个硬币
	void ReturnQtrs( ){ CurQtrs=0;}//返回现在的硬币数
	unsigned isAllowVend(){return allowVend;}// 返回允许售卖状态
	void Reset( ){totalQtrs=0;allowVend=0;CurQtrs=0;}//复位初始状态
	void Vend( );//如果允许售卖，更新硬币总数和现在的数量
｝

void CcoinBox::AddQtr( )
{
	CurQtrs=CurQtrs+1;	//增加一个硬币数
	if (CurQtrs>1)
		allowVend=1;
}
void CcoinBox::Vend( )
{
	totalQtrs=totalQtrs+CurQtrs;
	CurQtrs=0;
	allowVend=0;
}


```

分析上面的程序段内容，对allowVend 的测试的可能结果，有两个可能的区间或状态：[0,0],[1,M]。其中M是一个特定实现的最大无符号数值。CurQtrs也有同样的两个状态：[0,0],[1,M]。这样对于一个硬币盒共有4个状态：s1，s2，s3，s4。如图6-8所示。

![](https://img1.zlogs.net/20/20200117223112.png)

根据OSD模型要求，将上例复合OSD模型成COSD模型。

![](https://img1.zlogs.net/20/20200117223113.png)

硬币盒的COSD模型







#### 3、构造对象的状态图

​	从C++源程序代码构造OSD模型，从构造出的OSD可以测试发现对象状态行为的错误，这种状态测试方法称之为基于程序或白盒状态测试。

构造对象状态图的步骤如下：①象征性的执行类的每一个成员函数；②根据上面①执行的结果来识别状态；③根据上面①执行的结果来识别转换。



（1）象征性的执行类的每一个成员函数。

硬币盒类的象征性执行结果

| 路径             | 执行条件                | 最终表达式<变量，值>                                  | 结果值   |
| ---------------- | ----------------------- | ----------------------------------------------------- | -------- |
| Ccoinbox().p0    | T(不需要条件即始终满足) | <totalQtrs,0><allowVend,0><CurQtrs,0>                 | 无效     |
| Reset().p0       | T                       | <totalQtrs,0><allowVend,0><CurQtrs,0>                 | 无效     |
| AddQtr().p0      | !(CurQtrs>0)            | <CurQtrs,CurQtrs+1>                                   | 无效     |
| AddQtr().p1      | (CurQtrs>0)             | <CurQtrs,CurQtrs+1><allowVend,1>                      | 无效     |
| ReturnQtrs().p0  | T                       | <allowVend,0><CurQtrs,0>                              | 无效     |
| isAllowVend().p0 | T                       |                                                       | 允许售卖 |
| Vend().p0        | isAllowVend()==0        |                                                       | 无效     |
| Vend().p1        | !(isAllowVend()==0)     | <totalQtrs,totalQtrs+CurQtrs><CurQtrs,0><allowVend,0> | 无效     |



（2）根据象征性执行的结果来识别状态

​	生成状态的目的是在于解释类中的哪些基于数据成员所取的值的行为。当一个数据成员参与了一个在运行时控制着执行路径的决定（条件）时，它的值会影响到类的行为。这样，可以将数据成员值划分为几个区间，每个区间的数据成员的取值将导致不同的执行路径。

```
若一个条件语句仅有一个变量X是数据成员，用m和M分别表示数据成员X的值域中的最小值和最大值。数据成员X的状态识别步骤如下：
①检查所有的成员函数的路径条件中以X为条件的语句；
②对①中所识别出来的每一个条件语句，形成X的值域区间，对于区间中的所有取值，条件语句取真值或假值。
如：
条件语句			形成的区间
X>10, X<=10			[m, 10], [11, M]
X<10, X>=10			[m, 9], [10, M]
X==10, X!=10			[m, 9], [10,10], [11, M]
③由上得到的X的值域上的一个区间集合，然后将所有的区间进行简化成不相交的区间。其步骤如下：
a.选择任两个相交的区间A和B
b.形成新的区间A-(A∩B)，B-(A∩B)和(A∩B)
c.用以上的区间代替A，B
d.重复以上的步骤，直到不存在相交的区间为止。最后产生的区间就是状态。


```



```
 找出硬币盒中数据成员CurQtrs的状态。
	从路径条件中得知数据成员CurQtrs上的条件语句是CurQtrs>0和!( CurQtrs>0)；产生的区间是：[m, 0]，[1, M]，而无符号数m=0，所以区间为：[0, 0]，[1, M]。因为区间没有相互覆盖，所以是状态。
```





（3）根据象征性执行的结果来识别转换

​	设状态Si是一个区间[l,u]，如果一个数据成员的值在此区间中，我们就说这个数据成员处于状态Si，用Si (x)来表示表达式(x≥l)∧(x≤u),其中x是一个数据成员或一个变量表达式。PC表示一条路径，E表示一个数据成员d经由一条路径产生的一个终值表达式。

状态转换的构造步骤如下：

- ①生成一个状态的集合RS，将其初始值置空。
- ②将由构造函数产生的终值表达式的状态加入集合RS中，这些状态是初始状态（如果没有构造函数，将所有的状态加入RS中）。
- ③选择一个状态Si∈RS把它作为前端状态，若是初始状态，加上导致Si的构造函数的转换，并进行标记。
- ④选择定义数据成员d的路径Pk，PCk是路径Pk的路径条件，E是数据成员d的对这条路径的终值表达式。如果Si (d)∧PCk被满足，那么路径将导致从Si开始的一个转移；否则丢失Pk选择下一条路径。
- ⑤识别因为路径Pk，从状态Si出发的状转换所产生的所有状态从RS中选择一个状态Si，Sj是从Si开始的，经过路径Pk并满足条件产生转换的一个后继状态，即由于Pk if (Si(d)∧PCk)├Sj(E) 而得到的一个转换的后继状态。也就是说在所有的(Si(d)∧PCk)为真的情况下，Sj(E)必为真。把Sj加到RS中。
- ⑥选择所有的数据成员执行④⑤步的状态构造转换。
- ⑦将Si从RS中删除。
- ⑧从③开始重复到RS为空。




 4、基于OSD对象状态测试

（1）测试标准

对象状态标准：若对于OSD中的每一个状态S总有一个测试用例使得对象从初始状态到达状态S，称测试集合Tstate达到了对象状态标准。

对象转换标准：若对于OSD中的每一个转换δ（Si,tj）=Sj总有一个相应的测试用例t1…tj-1,tj,其中t1…tj-1使OSD从初始状态到达源状态Si，然后tj使OSD转换到目标状态Sj，称测试集合Ttran达到了对象转换标准。

条件转换标准：设δ（Si,C:tj）=Sj,是OSD从源状态转换到目的状态，总有一个测试用例得条件C为假，不产生状态转换，称测试集合Tctran达到了条件转换标准。

交互转换标准：对于OSD中的每一个交互转换总有一个测试用例使得这个交互转换得以执行，称测试集合Titran达到了交互转换标准。


（2）测试策略

采用什么样的测试策略使生成的“测试桩”的开销最小？我们采用“自底向上”的策略，其基本思想是：对于每一个复杂的对象Oi构造一个基于它的OSD的“状态结构图”，用于表示对象状态的层次结构。在一棵状态结构树中，根节点对应于对象Oi的OSD，内部节点表示的是聚集的对象和继承的部分COSD，叶子节点代表每一个COSD中的数据属性的AOSD。我们可以使用自底向上的策略对树中的每一个AOSD或COSD生成一个状态单元测试顺序，按照这个顺序就可以对每一个AOSD和COSD执行状态单元测试。



### 测试驱动的实现与代码的组织

1、测试代码的实现

(1)利用main函数

​	利用main函数来调用测试类，并实现测试是测试驱动中最简单的的方式，可以直接将每个测试用例写入到main函数中，然后将测试的结果直接输出到屏幕上。



```c++
例6-10 以例6-4自动售货机中的类Class CcoinBox为例，使用main函数方法对类Class CcoinBox进行测试，测试的驱动代码（C++源程序）如下：
#include<iostream>
using namespace std;
class CcoinBox
{
	unsigned totalQtrs;
	unsigned CurQtrs;
	unsigned allowVend;
 public:
	CcoinBox();
	~CcoinBox();
	void Reset();
	void Vend();
	void AddQtrs();
	void ReturnQtrs();
	unsigned isAllowVend();
private:
};

unsigned CcoinBox::isAllowVend()
{	return allowVend;	}
void CcoinBox::AddQtrs()
{	CurQtrs = CurQtrs + 1;
	if (CurQtrs > 1)
		allowVend += 1;}
void CcoinBox::ReturnQtrs()
{	CurQtrs = 0;
	allowVend = 0;}

void CcoinBox::Vend()
{	totalQtrs = totalQtrs + CurQtrs;
	CurQtrs = 0;
	allowVend = 0;}
void CcoinBox::Reset() 
{	totalQtrs = 0;
	CurQtrs = 0;
	allowVend = 0;}
CcoinBox::CcoinBox()
{	Reset();}
CcoinBox::~CcoinBox(){  }

void main()
{	CcoinBox cb; 
	cb.AddQtrs();
	cout << "放入一个硬币" << endl;
	cb.AddQtrs();
	cout << "放入一个硬币" << endl;
	cb.ReturnQtrs();
	cout << "退回所有硬币" << endl;
	if (cb.isAllowVend()) {
		cout << "售卖成功" << endl;
		cb.Vend();	}
	else	{	cout << "售卖失败" << endl;	}
	getchar();
}



```

![](https://img1.zlogs.net/20/20200117223114.png)





（2）嵌入静态方法

​	在被测试为中嵌入静态的方法，在静态方法内部实现测试用例执行，然后调用该静态方法，将执行的测试结果输出到屏幕。

例6-11以例6-4自动售货机中的类Class CcoinBox为例，使用静态方法进行测试，C++程序代码如下：



```
#include<iostream>
#include"SCcoinBox.h"
using namespace std;
void SCcoinBox::test()
{	SCcoinBox cb; 
	cb.AddQtrs();
	cout << "放入一个硬币" << endl;
	cout << "当前硬币数：" << cb.getCurQtrs() << endl;
	cb.AddQtrs();
	cout << "放入一个硬币" << endl;
	cout << "当前硬币数：" << cb.getCurQtrs() << endl;
	cb.AddQtrs();
	cout << "放入一个硬币" << endl;
	cout << "当前硬币数：" << cb.getCurQtrs() << endl;	

 cb.AddQtrs();
	cout << "放入一个硬币" << endl;
	cout << "当前硬币数：" << cb.getCurQtrs() << endl;
	//cb.ReturnQtrs();
	//cout << "退回所有硬币" << endl;
	while (cb.isAllowVend()) {
		cout << "售卖成功" << endl;
		cb.Vend();
		cout << "当前硬币数：" << cb.getCurQtrs() << endl;
		cout << "总的硬币数：" <<cb.getTotalQtrs()<< endl;
	}
	getchar();
}

unsigned SCcoinBox::getTotalQtrs()
 {	return totalQtrs;     }
unsigned SCcoinBox::isAllowVend()
{	return allowVend;   }
void SCcoinBox::AddQtrs()
{	CurQtrs = CurQtrs + 1;
	/*if (CurQtrs > 1)
		allowVend += 1;*/
	allowVend = CurQtrs / 2;//修改后
}
void SCcoinBox::ReturnQtrs()
{	CurQtrs = 0;
	allowVend = 0;
}

unsigned SCcoinBox::getCurQtrs()
{	return CurQtrs;	}
void SCcoinBox::Vend()
{	totalQtrs = totalQtrs + 2;
	CurQtrs -= 2;
	allowVend--;	}
void SCcoinBox::Reset()
{	totalQtrs = 0;
	CurQtrs = 0;
	allowVend = 0;	}
SCcoinBox::SCcoinBox()
{	Reset();	}
SCcoinBox::~SCcoinBox(){	}



```





##  面向对象的集成测试和系统测试

### 面向对象的集成测试

- 面向对象的集成测试通常需要在整个程序编译完成后进行。
- 此外，面向对象程序具有动态特性，程序的控制流往往无法确定，因此也只能对整个编译后的程序做基于黑盒子的集成测试。
- 类簇测试内容
  - 面向对象的集成测试主要是测试类簇。
  - 类簇测试的主要内容如下：
  - （1）关联和聚合关系的测试
  - （2）继承关系的测试
  - （3）多态/动态绑定的测试
- 类集成测试的策略
  - 面向对象软件的类集成测试的两种不同策略。
  - （1）基于线程的测试：这种测试策略集成对某输入或事件作出回应的相互协作的一组类（即一个线程），分别集成并测试每个线程，同时应用回归测试保证没有产生副作用。
  - （2）基于使用的测试：这种策略通过测试那些很少使用服务器类的类（称为独立类）而开始构造系统，在独立类测试完成后，再增加使用独立类的类（称为依赖类）进行测试，一直到构成完整的系统。
  - 在面向对象集成测试中应注意几个方面：
    - ①面向对象系统本质上是通过小的、可重用的组件构成，所以，集成测试对于面向对象系统来说更重要。
    - ②面向对象系统下组件的开发一般更具有并行性，所以，对频繁集成的要求更高。
    - ③由于并行性的提高，集成测试时需要考虑类的完成顺序，也需要设计驱动器来模拟其他没有完成的类的功能。
- 类集成测试的测试过程及测试用例的生成
  - 面向对象的集成测试能够检测出相对独立的单元测试无法检测出的哪些类相互作用时才会产生的错误。
  - 基于单元测试对成员函数行为正确性的保证，集成测试只关注系统的结构和内部的相互作用。
  - 面向对象的集成测试可以分成两步进行：先进行静态测试，再进行动态测试。
  - 静态测试
    - 静态测试主要针对程序的结构进行，检测程序结构是否符合设计要求。现在流行的一些测试软件都能提供一种称为“可逆性工程”的功能，即通过源程序得到类关系图和函数功能调用关系图，例如Internationa1d Software Automation公司的Panorama—2for Windows 95、Rational公司的Rose C++ Analyzer等，将“可逆性工程”得到的结果与OOD(面向对象设计)的结果相比较，检测程序结构和实现上是否有缺陷。换句话说，通过这种方法检测OOP(面向对象编程)是否达到了设计要求。
  - 动态测试
    - 动态测试设计测试用例时，通常需要功能调用结构图、类关系图或者实体关系图为参考，确定不需要被重复测试的部分，从而优化测试用例，减少测试工作量，使得进行的测试能够达到一定覆盖标准。测试所要达到的覆盖标准可以是：达到类所有的服务要求或服务提供的一定覆盖率；依据类间传递的消息，达到对所有执行线程的一定覆盖率；达到类的所有状态的一定覆盖率等。同时也可以考虑使用现有的一些测试工具来得到程序代码执行的覆盖率。
  - 具体设计测试用例步骤：
    - ①先选定检测的类，参考OOD分析结果，仔细判断出类的状态和相应的行为，类或成员函数间传递的消息，输入或输出的界定等。
    - ②确定覆盖标准。
    - ③利用结构关系图确定待测类的所有关联。
    - ④根据程序中类的对象构造测试用例，确认使用什么输入激发类的状态、使用类的服务和期望产生什么行为等。

### 面向对象的系统测试

- 面向对象的系统测试是对所有类和主程序构成的整个系统进行的整体测试，以验证软件系统的正确性和性能指标，满足规格说明书和任务书所指定的要求。其测试用例可以从对象-行为模型和作为面向对象分析的一部分的事件流图中导出。
- 面向对象的系统测试应该尽量搭建与用户实际使用环境相同的测试平台，应该保证被测系统的完整性，对临时没有的系统设备部件也应有相应的模拟手段。
- 面向对象的系统测试的具体测试内容
  - （1）功能测试
  - （2）强度测试
  - （3）性能测试
  - （4）安全测试
  - （5）恢复测试
  - （6）可用性测试
  - （7）安装/卸载测试等等。
- 面向对象系统的测试工具
  - （1）用例
  - （2）类图
  - （3）序列图
  - （4）活动图
  - （5）状态图