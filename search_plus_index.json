{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/1010.html":{"url":"page/1010.html","title":"简介","keywords":"","body":"简介 "},"page/1011.html":{"url":"page/1011.html","title":"概述","keywords":"","body":"概述 软件开发过程的三个阶段：定义阶段、开发阶段、检验交付与维护阶段， 软件开发过程中的活动与角色， 软件开发的开发模型有线性顺序模型、原型模型、快速开发模型、演化软件过程模型等， 软件开发与软件测试的关系等。 软件测试的七条基本原则， 软件测试方法常用有：静态测试、动态测试、白盒测试、黑盒测试、灰盒测试、人工测试、自动化测试、模型检测、冐烟测试、随机测试等。 软件测试的五种过程模型：V-model、W-model、H-model、X-model、 pretest-model。 "},"page/1012.html":{"url":"page/1012.html","title":"背景","keywords":"","body":"背景 软件的缺陷及其影响 什么是软件缺陷 软件缺陷就是软件产品中所存在的问题，最终表现为用户所需要的功能没有完全实现，不能满足或不能全部满足用户的需求。 从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、误差等各种问题。 从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。 软件缺陷的类型： （1）软件未实现产品说明书要求的功能。 （2）软件出现了产品说明书不应该出现的错误。 （3）软件实现了产品说明书未提到的功能。 （4）软件未实现产品说明书虽未明确提及但应该实现的功能。 （5）软件难以理解、不易使用、运行缓慢——从测试员的角度看——最终用户会认为不好。 存在软件缺陷的案例及影响 （1）千年虫问题（产生约1974年） 　　　　日期存储未存储世纪 （2）爱国者导弹防御系统（1991年） 　　　　时钟计算做了一个舍入操作，二进制转十进制，无限循环导数 （3）英特尔奔腾浮点除法缺陷（1994年） 　　　　 （4）“冲击波”病毒（2003年） 　　　　 （5）诺基亚手机平台缺陷（2008年） 　　　　 软件测试的产生与发展 软件测试的产生 软件缼陷产生的主要原因： （1）需求解释有错误； （2）用户定义错误； （3）需求记录错误； （4）设计说明错误； （5）编码说明有误； （6）程序代码有误； （7）其他有误，如：数据输入等。 软件测试的发展 （1）初级阶段（1957-1971年） （2）发展阶段（1972-1982年） （3）成熟阶段（1983年至今） 修复软件缺陷的成本 软件开发过程是使用软件工程的方法，在整个过程中，都有可能出现各种各样的软件缺陷。随着开发时间的推移，软件缺陷修复成本呈倍数的增长。假如早在进行分析时发现相关功能缺失，立即补上就可了，可以说付出的代价小得几乎忽略不计。如果在发布时发现缺失某个功能，那么此时加上一个功能，相当于重新开发一样，这时的修补费用可以说高许多。因此要尽早进行测试。 "},"page/1013.html":{"url":"page/1013.html","title":"基本概念","keywords":"","body":"基本概念 软件测试的定义 软件测试专家G.J.Myers早在1979年给软件测试下定义：软件测试是为了发现错误而针对某个程序或系统的执行过程。 G.J.Myers给出与测试相关的三个要点： （1）测试是为了证明程序有错，而不是证明程序无错误； （2）一个好的测试用例是在于它能发现至今未发现的错误； （3）一个成功的测试是发现了至今未发现的错误的测试。 1990年，IEEE再次给出软件测试的定义： （1）在特定的条件下运行系统或构件，观察或记录结果，对系统的某个方面做出评价； （2）分析某个软件项以发现现存的和要求的条件之差别并评价此软件项的特性。 软件测试用例 1、软件测试用例定义 IEEE标准610（1990）给出的定义： 测试用例是一组测试输入、执行条件和预期结果的集合，目的是要满足一个特定的目标，比如执行一条特定的程序路径或检验是否符合一个特定的需求。 2、测试用例的元素 软件测试设计的关键问题可以概括为5W1H: Why:为什么测试？对功能、性能、可用性、容错性、安全性等测试，检验是否符合相关要求。 What:测什么？测试的对象可以是文档，代码，图表等。 Where:在哪里测？测试用例的环境，包括系统的硬件、软件和网络环境等。 When:什么时候测？测试用例所需的前提条件，尽早开始。 Which:什么数据？测试用例设计的各种数据。 How:如何执行？结果怎样？要据测试用例设计的步骤来执行，最后进行结果比较，确定是否一致。若一致才能通过测试。 3、测试用例设计的基本原则 从两个层次考虑测试用例： （1）低层次——从单个测试用例看，衡量其描述的规范性、可理解性及可维护性条等。 （2）高层次——以满足某一个测试目标或测试任务来衡量一组测试用例的结构、设计思路和覆盖率等； 测试用例的基本原则: （1）代表性。测试用例能代表并覆盖各种合法的或不合法、边界内的或越界的以及极限的输入数据、操作和环境的设置。 （2）可判定性。测试执行的结果的正确性是可以判定的。每一个测试用例都应有相应的预期结果。 （3）可再现性。对于同样的测试用例，系统执行的结果应当相同的，并且相同的测试的执行过程可以反复操作。 4、测试用例模板 XX测试安装用例 编号 测试内容安装测试 是否通过 1 执行典型安装：执行安装步骤，按功能测试方法确认功能正确，包括各种控件、回车键、Tab键、快捷键、错误提示信息等 2 执行自定义安装：执行安装步骤，按功能测试方法确认功能正确，包括各种控件、回车键、Tab键、快捷键、错误提示信息等。选择与典型安装不同的安装路径和功能组件 3 执行网络安装：执行安装步骤，按功能测试方法确认功能正确，包括各种控件、回车键、Tab键、快捷键、错误提示信息等 4 取消或关闭安装过程，程序没有安装，检查注册表、安装路径中是否存在程序的任何信息 5 按界面和易用性测试规则，检查安装中的所有界面 6 按文档测试规则，检查安装中的所有文档（帮助、许可协议等） 7 突然中断安装过程（网络安装还要考虑网络中断） 8 安装过程中介质处于忙碌状态 软件测试环境 1、什么是测试环境 软件测试环境就是软件测试运行的平台。包括系统的硬件、软件和网络等。 可以用一公式来表示： 测试环境=硬件+软件+网络+数据 2、测试环境的搭建和维护 （1）机房环境的建立 （2）硬件环境的建立 （3）软件环境的建立 （4）网络环境的建立 （5）安全措施的实施 软件测试人员的要求 1、软件测试人员的角色与职责 测试人员的角色主要有四类： （1）测试经理：主要负责测试队伍的内部管理以及与外部人员、客户的交流工作，包括进度管理、风险管理、资金管理、人力资源管理、交流管理等。还有测试计划书的编写、测试总结报告的归纳等。必须具有项目经理的知识和技能。 （2）测试设计师：主要根据软件开发各阶段产生的设计文档来设计各阶段的测试用例。 （3）测试文档审核师：主要负责前置测试，包括对各个阶段的分析与设计文档进行审核，如：需求说明书、概要与详细设计说明书等。 （4）测试工程师：对测试设计师设计的测试用例分阶段完成测试工作。 2、软件测试人员的基本素质要求 基本素质要求如下： （1）具备计算机软件测试的基本理论知识 （2）熟悉开发工具和平台 （3）掌握测试工具的使用 （4）善于学习，理解与归纳 （5）耐心、细致、工作态度好 "},"page/1015.html":{"url":"page/1015.html","title":"与软件开发关系","keywords":"","body":"与软件开发关系 1.软件开发过程概述 1.1 软件开发的阶段、活动及角色 1、软件工程的阶段 软件工程的三个阶段: 定义、开发、检验交付与维护 (1)定义阶段：可行性研究初步项目计划、需求分析。如图2-1所示。 图2-1软件工程的定义阶段 (2)开发阶段：概要设计、详细设计、实现、测试。如图2-2所示。 图2-2 软件工程的开发阶段 (3)检验交付与维护阶段：运行、维护、废弃。如图2-3所示。 图2-3 软件工程的检验交付与维护阶段 2、软件开发过程的活动 通常包括四种基本过程活动： （1）软件规格说明：规定软件的功能、性能及其运行限制。 （2）软件开发：产生满足规格说明的软件，包括设计与编码等工作。 （3）软件确认：确认软件能够满足客户提出的要求，对应于软件测试。 （4）软件演进(软件的维护)：为满足客户的变更要求，软件必须在使用过程中演进，以求尽量延长软件的生命周期。 3、开发过程中的角色 （1）项目经理：负责管理业务应用开发和系统开发项目。 （2）业务分析人员：理解和描绘客户的要求，引导和协调用户和业务需求的收集和确认，并使文档化。 （3）架构师：负责理解系统的业务需求，并创建合理、完善的系统体系架构。并决定相关技术的选择。 （4）数据设计人员：负责定义详细的数据库设计。 （5）程序员：设计、编写程序代码及内部设计规格说明。 （6）测试人员：负责制定测试计划，并根据计划进行相关测试，找出产品中的问题。 （7）产品经理：负责产品的交付和发布，以及销售产品。 （8）技术支持代表：负责处理客户的投诉，以及售后服务问题。 1.2 软件开发的过程模型 1、线性顺序模型（瀑布模型） （1）各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量； （2）由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； （3）早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 图2-4 线性顺序模型 2、（快速）原型模型 原型模型从需求收集开始，开发者与用户在一起定义软件的总体目标，标识出已知的需求，并规划出进一步定义的区域，然后快速地设计并进行编码实现，建立好原型。在原型模型的基础上，运行、评估、修改，多次迭代进行，直到满足用户的需求为止。 图2-5 原型模型 3、快速开发模型 采用RAD模型时，系统的每一个主要功能部件都可由一个单独的RAD工作组完成，最后将所有的部件集成起来构成完整的软件。 RAD模型强调可复用程序构件的开发，并支持多小组并行工作。但若一个系统很难模块时，构件的复用和建造会出现许多问题，不适用于技术风险高、采用新技术的项目。 图2-6快速开发模型 4、演化软件过程模型 （1）增量模型：将线性模型与原型模型结合起来，随着日程/时间的进展而交错析线性序列集合。如图2-7所示。 （2）螺旋模型：也是将线性模型与原型模型结合起来，并加入风险分析。如图2-8所示： 螺旋模型被划分为若干框架活动：用户通信、计划、风险分析、工程、建造及发布、用户评估等。 螺旋模型适应于计算机软件产品的整个生命周期。对于大型系统的开发是一种模型方法。 1.3 软件测试与软件开发的关系 软件测试在软件开发过程中占有重要的地位，在传统的瀑布模型中，软件测试只成为其阶段性的一段工作——进行代码的测试。而现代软件工程思想将软件测试认为是贯穿整个软件生命周期，并且是保证软件质量的重要手段之一。 有些研究数据显示，在国外软件开发的工作量中，软件测试的工作量占有总工作量的40%左右；软件开发的总费用中软件测试占有30%-50%。对于一些高科技开发系统，软件测试占有的时间和费用可能更多更高。 2.软件测试方法在软件开发过程的运用 1、在软件需求分析与建模阶段中 主要进行软件目标的定义，可行性研究和软件需求分析工作。 这时测试的对象是相关文档资料，如：需求规格说明书等。从需求的完备、可实现、是否合理、是否可测试等方面进行评审，采用的静态测试方法。 2、在概要设计与详细设计阶段 概要设计描述总体系统架构中各个模块的划分及相互之间的关系；详细设计则描述各个模块具体的算法和数据结构。 这些都是用文字、图表的形式进行描述的，测试时也是用静态测试的方法，对文字、图表进行评审。 3、在编码工作阶段 主要是采用高级语言对已详细设计的模块进行编程。 这时的测试工作主要是对已有的程序代码进行白盒测试，可以是静态与动态相结合，采用各种覆盖方法进行测试，此时主要由程序员进行测试。 4、在测试阶段中 此时进行的集成与系统测试。 集成测试采用灰盒测试方法（白盒测试与黑盒测试相结合），主要测试产品的接口以及各模块之间的关系。而系统测试一般采用黑盒测试方法，主要测试系统的功能、性能等；由测试人员来完成测试。 5、在检验交付与维护阶段 模拟或实际客户环境，对系统进行验收测试。 大多采用自动化测试工具进行测试验收。包括功能测试、性能测试、回归测试、发布测试等。 "},"page/1016.html":{"url":"page/1016.html","title":"过程模型","keywords":"","body":"过程模型 软件测试的过程模型 相当于把软件测试作为项目 1V_model v-model模型是最早的软件生存期模型，在20世纪80年代由Paul Rook提出的。 v-model包含了三个等级，分别是生存期模型，分配模型，功能性工具需求模型，阐述了应当实施哪些活动，应当产生哪些结果，诸如此类。 V-model指出，单元测试所检测代码的开发是否符合详细设计的要求。集成测试所检测此前测试过的各组成部分是否能完好地结合到一起。系统测试所检测已集成在一起的产品是否符合系统规格说明书的要求。而验收测试则检测产品是否符合最终用户的需求。所以V-model模型软件测试的策略既包括低层测试又包括高层测试，底层测试是为了验证系统源代码的正确性，高层是为了测试整个系统是否满足用户的需求。 V-model的缺陷:仅仅把测试过程作为在需求分析、系统设计及编码之后的一个阶段忽视了测试对需求分析,系统设计的验证，一直到后期的验收测试才被发现。 2W-model W模型由Evolutif公司提出，相对于V-model，W-model更科学,W-model是V-model的发展。由于V-model的局限性，没有明确地说明早期的测试,无法体现“尽早地和不断地进行软件测试”的原则。在V-model中增加软件各开发阶段应同步进行的测试，演化为W-model。如图2-12所示。 W-model，强调的是测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、功能和设计同样要测试。测试与开发是同步进行的，从而有利于尽早地发现问题。以需求为例，需求分析一完成，我们就可以对需求进行测试，而不是等到最后才进行针对需求的验收测试。 W-model的局限性：W模型和V模型都把软件的开发视为需求、设计、编码等一系列串行的活动，软件开发和测试保持一种线性的前后关系，需要有严格的指令表示上一阶段完全结束，才可以正式开始下一个阶段。这样就无法支持迭代、自发性以及变更调整。对于当前很多文档需要事后补充，或者根本没有文档的做法下，开发人员和测试人员都面临同样的困惑。 3H-model H-model。它将测试活动完全独立出来，形成一个完全独立的流程，将测试准备活动和测试执行活动清晰地体现出来。如图2-13所示： H-model揭示了： （1）软件测试不仅仅指测试的执行，还包括很多其他的活动（测试准备、测试之后的事情）； （2）软件测试是一个独立的流程，贯穿产品整个生命周期，与其他流程并发地进行； （3）软件测试要尽早准备，尽早执行； （4）软件测试是根据被测物的不同而分层次进行的。不同层次的测试活动可以是按照某个次序先后进行的，但也可能是反复的。 4X-model X-model的基本思想是由Marick提出的，他认为一个模型必须能处理开发的所有方面，包括交接，频繁重复的集成，以及需求文档的缺乏等等。 而X-model填补了V-model 的缺陷，并可为测试人员和开发人员带来明显的帮助。如图2-14所示。 5 pretest-model pretest-model，它是将测试和开发紧密结合的模型，该模型提供了轻松的方式，可以使你的项目加快速度。如图2-15所示。 Pretest-model体现了以下的要点： （1）开发和测试相结合 （2）对每一个交付内容进行测试 （3）在设计阶段进行测试计划和测试设计 （4）测试和开发结合在一起 （5）让验收测试和技术测试保持相对独立 6测试模型的使用 　　V-model强调了在整个软件项目开发中需要经历的若干个测试级别，而且每一个级别都与一个开发级别相对应，但它忽略了测试的对象不应该仅仅包括程序，或者说它没有明确地之处应该对软件的需求、设计进行测试。 　　W-model强调了测试计划等工作的先行核对系统需求和系统设计的测试，但W-model和V-model一样也没有专门对软件测试流程予以说明，因为事实上，随着软件质量要求越来越为大家所重视，软件测试也逐步发展成为一个独立于软件开发部的组织，就每一个软件测试的细节而言，它都有一个独立的操作流程。比如，现在的第三方测试，就包含了从测试计划和测试案例编写，到测试实施以及测试报告编写的全过程， H-model强调测试是独立的，只要测试准备完成，就可以执行测试了。 　　X-model和Pretest-model又在此基础上增加了许多不确定因素的处理情况，因为在真实项目中，经常会有变更的发生，例如需要重新访问前一阶段的内容，或者跟踪并纠正以前提交的内容，修复错误，排除多余的成分，以及增加新发现的功能等。 "},"page/1014.html":{"url":"page/1014.html","title":"软件测试基本原则","keywords":"","body":"软件测试的基本原则 1、测试不是为了证明系统的正确性，而是为了证明系统存在缺陷； 2、所有的测试都应该追溯到用户的需求； 3、测试应当尽早开始和不断进行； 4、穷举测试是不可能的； 5、第三方测试会更客观、更有效； 6、Pareto原则应用于软件测试； 7、软件测试是有风险的行为；但并非所有的测试都要修复； 8、测试应从小规模开始，逐步转向大规模； 9、软件测试是一项讲究条理的技术专业。 "},"page/1017.html":{"url":"page/1017.html","title":"分类","keywords":"","body":"软件测试方法的分类 静态测试与动态测试 1、静态测试 静态测试，是不需要执行被测软件，而是采用分析和查看的方式，来发现软件当中的缺陷，包括需求文档、源代码、设计文档、以及其他与软件相关文档中的二义性和错误。最好由未参加代码编写的个人或小组来完成。测试小组还能够使用一个或多个静态测试工具，以源程序代码作为输入，产生大量的在测试过程有用的数据。如图2-9所示。 图2-9 静态测试的要素 静态测试常用的方法如下： （1）走查 走查是个非正式的过程，检查所有与源程序代码相关的文档。 （2）审查 审查比走查要求更加正规。 （3）静态代码分析工具 静态结构分析主要是以图形的方式表现程序的内部结构 2、动态测试 动态测试是指通过运行实际被测试软件，通过观察程序运行时所表现的状态、行为等来发现软件的缺陷。并对被测程序的运行情况进行分析对比，以便发现程序表现的行为与设计规格或客户需求不一致的地方。 动态测试一般包括功能确认与接口测试，覆盖率分析、性能分析、内存分析等。 动态测试是一种经常运行的测试技术。但也有它的局限性：必须要借助测试用例完成；需要搭建特定的测试环境；不能发现文档中的问题。 由于动态测试与静态测试之间存在一定的协同性，又具有相对的独立性。所以在程序执行前进行静态测试，尽可能多地发现代码中隐含的缺陷；执行动态测试检查程序实时的行为，发现程序在运行时存在的缺陷。 黑盒测试与白盒测试 1、黑盒测试 黑盒测试又称功能测试或数据驱动测试；是将被测试软件看做一个黑盒子，完全不考虑程序的内部结构和处理过程，只考虑系统的输入和输出，在程序的接口进行测试，检查系统功能是否符合需求规格说明书的要求。 常用的测试方法有：等价类划分、边界值法、决策表法、因果图法、错误推测试法等。 黑盒测试的优点:黑盒测试用例与程序如何实现无关；测试用例的设计与程序开发可并行设计；没有编程经验的人也可以设计测试用例。 黑盒测试的局限性：不可能做到穷举测试；可能存在漏洞。 2、白盒测试 白盒测试又称结构测试或逻辑驱动测试；是根据被测试程序源代码的内部结构来设计测试用例的方法。 常用的测试方法有：逻辑覆盖、基本路径和数据流测试等。 白盒测试的优点：可以利用不同的覆盖准则测试程序代码的各个分支，发现程序内部的编码错误；可以直接发现内存泄露问题；可以充当黑盒测试的检查手段等。 白盒测试的局限性：因程序路径组合太多，同样不能做到穷举测试；由于设计测试用例不是根据客户需求说明进行的测试，可能存需求方面的漏洞。 3、灰盒测试 灰盒测试结合了白盒测试和黑盒测试的要素，关注输入的正确性，同时了关注内部的表现；考虑了用户端、特定的系统知识和操作环境。它在系统组件的协同环境中评价应用软件的设计。 人工测试与自动化测试 按照测试执行时是否需要人工干预进行分类，可分为人工测试与自动测试。 1、人工测试 人工测试是人为测试和手工测试的统称。人为测试的主要方法有桌前检查、代码审查和走查。用于软件开发各阶段的审查或评审都是人为测试。手工测试主要指在测试过程中，按照测试计划一步一步执行程序，得出测试结果并进行分析的测试行为。 2、自动测试 自动化测试指的是利用测试工具对各种测试活动的管理与执行，并对测试结果自动进行分析。在测试的执行过程中，一般不需要人工干预。常用在功能测试、回归测试和性能测试等。 自动化测试的优点：提高测试效率；降低测试成本；具有一致性和可重复性；降低风险，增加软件的质量等。 自动化测试的局限性：自动化测试软件本身的问题；测试人员期望过高；有些人工测试是不能用自动化测试替代等。 其他测试分类 1、基于模型的测试与模型检测 基于模型的测试，是指对软件行为进行建模以及根据软件的形式化模型设计测试的活动。 模型检测是指，用来验证软件特定模型中的一个或多个特性的一类技术。 　　模型通常是有限状态的，是从一些原始材料中提取出来的，这些原始材料可能是需求文档，也可能是系统源代码本身。有穷状态模型中的每一个状态前都有一个或多个前置条件，当软件处于该状态时，这些特性必须满足。见图2-10所示说明模型检测过程。 图2-10模型检测的要素 2、冒烟测试 冒烟测试是指在测试中发现问题，也就是说找到了一个缺陷，由开发人员来修复这个缺陷，当修复完成后，是否真的解决了这个缺陷，或对其他模块是否存在影响，因此要针对这个问题进行专门的测试，这个测试过程称为冒烟测试。 在许多情况下，经过测试后，发现修复某个问题会引起其他功能模块一系列的反应，导致产生新的缺陷。冒烟测试的优点是节省测试时间，防止创建失败。缺点是覆盖率较低。 3、随机测试 随机测试是根据测试说明书执行样例测试的一种重要补充手段，是保证测试覆盖完整性的有效方式和过程。随机测试主要针对系统的一些重要功能进行复测。还对软件更新和新增的功能要进行重点测试。常与回归测试一起进行。 "},"page/1018.html":{"url":"page/1018.html","title":"是否执行软件","keywords":"","body":"是否执行软件 "},"page/1019.html":{"url":"page/1019.html","title":"静态测试","keywords":"","body":"静态测试 "},"page/1020.html":{"url":"page/1020.html","title":"动态测试","keywords":"","body":"动态测试 "},"page/1021.html":{"url":"page/1021.html","title":"是否了解代码","keywords":"","body":"是否了解代码 "},"page/1022.html":{"url":"page/1022.html","title":"白盒测试","keywords":"","body":"白盒测试概念 定义 白盒测试又称为结构测试或逻辑驱动测试，是针对被测试程序单元内部如何工作的测试，特点是基于被测试程序的源代码，而不是软件的需求规格说明。 使用白盒测试方法时，测试者必须全面了解程序内部逻辑结构，检查程序的内部结构，从检查程序的逻辑着手，对相关的逻辑路径进行测试，最后得出测试结果。 采用白盒测试方法必须遵循原则 （1）保证一个模块中的所有独立路径至少被测试一次。 （2）所有逻辑值均需测试真值和假值两种情况。 （3）检查程序的内部数据结构，保证其结构的有效性。 （4）在上下边界及可操作范围内运行所有循环。 白盒测试流程 NC（Network Computer）系统中的对象主要分为如下几种： 界面对象UI(UI Object) 界面对象测试的流程图 数值对象VO(Value Object) 业务对象测试的流程图 业务对象BO(Business Object) 数据管理对象DMO(Data Manage Object) 其优缺点比较如下： 界面对象测试流程的优点是便于测试者从界面层直观地录入数据，缺点是做回归测试时，录入数据需重复。 业务对象测试原则是从底层测试，底层测试通过了，再依次往上一层测试；否则不需往上层测试，优点是做回归测试时，不用再构造输入数据，只要再执行一遍小测试程序。缺点是需给中间层做一测试小程序，根据程序中类的对象构造输入数据及将结果输出到控制台上。 白盒测试要求 白盒测试问题类别分为以下几大类: 各层公用问题、JAVA语言规范、数据类型、SQL语句规范、界面UI 、VO数值对象、BO业务对象、DMO数据管理对象、业务逻辑重点、事务处理与隔离级别测试、效率测试。 问题属性分为四类：错误、缺陷、失效、故障。 错误是指计算值、观测值、测量值之间，或条件与真值之间，不符合规定的或理论上的正确值或条件。 缺陷是指与期望值或特征值的偏差。 故障是指功能部件不能执行所要求的功能。故障可能由错误、缺陷或失效引起。 失效是指功能部件执行其功能的能力丧失，系统或系统部件丧失了在规定限度内执行所要求功能的能力。 "},"page/1077.html":{"url":"page/1077.html","title":"程序复杂度及度量方法","keywords":"","body":"程序复杂度及度量方法 程序复杂度及度量方法 ​ 在实际的软件开发过程中，人们发现程序的复杂度不仅影响软件的可维护性、可测试性及可靠性等，而且与软件中故障的数量、软件的开发成本及软件的效率有关。 流图的概念 ​ 流图又称程序图，实际上可以看作是一种简化了的程序流程图。在流图中，只关注程序的流程，不关心各个处理框的细节，因此，原来程序流程图中的各个处理框（包括语句框、判断框、输入/输出框等）都被简化为结点，一般用圆圈表示，而原来程序流程图中的带有箭头的控制流变成了程序图中的有向边。 ​ 结构化程序设计中的几种基本结构的流图。如图3-2所示。 ​ 简化后的流图只有两种图形符号：结点和控制流线。结点用带标号的圆圈表示，可以代表一个或多个语句、一个处理框或一个判断框。控制流线用带箭头的弧线表示，代表程序中控制流。 ​ 从图论的观点来看，流图是一个可表示为G=的有向图。其中，N表示图中的结点，而E表示图中的有向边。 ​ 流图可以通过简化程序流程图得到，也可以由PAD图或其他详细设计表达工具变换得到。 图3-3是典型的程序流程图转换为相对应的流图。对图3-3中的（a）所示的程序流程图进行简化，得到图3-3（b）所示的流图。 图3-3程序流程图及对应的流图（a）程序流程图；（b）流图 环形复杂度 ​ 环形复杂度又称为圈复杂度，是一种为程序逻辑复杂度提供定量尺度的软件度量。它可以提供程序基本集的独立路径数量和确保所有语句至少执行一次的过程。常用于基本路径测试法。 ​ 环形复杂度的度量方法又称为McCabe方法。一个强连通流图中线性无关的有向环的个数就是该程序的环形复杂度。而强连通图，是指从图中任意一个结点出发都能到达图中其他结点的有向图。 ​ 在图论中可以通过以下公式来计算有向图中线性无关的有向环的个数。 $ V（G）=m-n+p ① $ 其中：V（G）表示有向图G中的线性无关的环数； ​ m表示有向图G中有向边的个数； ​ n表示有向图中的结点数； ​ p表示有向图G中可分离出的独立连通区域数，为常数1。 ​ 流图虽为连通图，但不是强连通图，可以在流图中增加一条出口点到入口点的虚弧线，此时，流图就变成了一个强连通图。如图3-4所示，在图3-3（b）流图添加虚弧后得到的强连通图。 图3-4将图3-3（b）变换后的强连通图 采用上面的公式①计算它的环形复杂度为: $V（G）=13-10+1=4 $ （加一是考虑虚弧） 图3-4强连通图的复杂度是4，因此图3-4中有4个线性独立环路。此时删除从结点E到结点S的虚弧，则这4个环路就是结点S到结点E的线性独立路径。 4条线性独立路径： Path1: S→a→b→g→E Path2: S→a→b→g→h→E Path3: S→a→b→c→d→f→b→g→E Path4: S→a→b→c→e→f→b→g→E 除了采用上面的公式①可以计算环形复杂度外，还可以用其他的公式计算出流图中的环形复杂度。 V（G）=强连通的流图在平面上围成的区域数​ ② 图3-4中，流图中围成的区域有（b,c,d,f,b），（c,d,f,e,c），（g,h,E,g）和（S,a,b,g,E,S），因此公式②计算得到的流图环形复杂度为4。 V（G）=判定结点数+1​ (判定节点为出来弧>1)③ 在图3-4中，判定结点分别为b，c和g，根据公式③可得环形复杂度为：3+1=4。 图矩阵 ​ 图矩阵是流图的邻接矩阵的表示形式，其阶数等于流图的结点数，矩阵的每列与每行都对应于标识的某一结点，矩阵元素对应于结点之间的存在的边；有边取值为1，否则为0或不填。 ​ 如图3-5和图3-6所示，一个简单流图及对应的邻接矩阵： 行相加判断是否是判定结点 "},"page/1039.html":{"url":"page/1039.html","title":"静态白盒测试方法","keywords":"","body":"静态白盒测试方法 静态白盒测试主要通过审查、走查、检验等方法，来查找代码中的问题和缺陷。 主要原因是为了尽早发现软件缺陷，以找出黑盒测试难以发现或隔离的软件缺陷。 其次，为黑盒测试员在接受软件进行测试设计时，设计和应用测试用例提供思路。 通过审查评论，可以确定有问题或者容易产生软件缺陷的特性范围。 "},"page/1040.html":{"url":"page/1040.html","title":"检查设计和代码","keywords":"","body":"检查设计和代码 静态白盒测试是在不执行软件的条件下有条理地仔细审查软件设计、体系结构和代码，从而找出软件缺陷的过程。有时又称为结构化分析。 "},"page/1041.html":{"url":"page/1041.html","title":"正式审查","keywords":"","body":"正式审查 1、正式审查有四个要素 （1）确定问题 （2）遵守规则 （3）准备 （4）编写报告 2、正式审查的效果 正式审查的主要的目的是找出软件中存在的缺陷，除此之外，还可以形成一些间接的效果。如：程序员与程序、测试人员之间的交流，增强相互了解；程序员会更仔细的编程，提高正确率等。正式审查是把大家聚在一起讨论同一个项目问题的良机。 3、正式审查几种类型 （1）同事审查 （2）走查 （3）检验 "},"page/1042.html":{"url":"page/1042.html","title":"编码标准和规范","keywords":"","body":"编码标准和规范 在编程和审查程序代码时，建立相关的规范和标准，并坚持标准或规范。 三个重要的原因： （1）可靠性：坚持按照某种标准和规范编写的代码更加可靠和安全。 （2）可读性/维护性：符合设备标准和规范的代码易于阅读、理解和维护。 （3）移植性：代码符合设备标准，迁移到另一个平台就会轻而易举，甚至完全没有障碍。 1、编程标准和规范示例 （1）编程标准的4个组成部分 ①标题：描述标准包含的主题。②标准（或规范）：描述标准或规范的内容。③解释说明：给出标准背后的原因，以使程序员理解为什么这样是好的编程习惯。④示例：给出如何使用标准的简单程序示例。 （2）示例 图3-1 C++中所用C语言特性的程序示例如图3-1所示，是一个针对C++中所用的C语言特性的规范示例。说明在C++中如何使用某些C语言特性的编程。 2、获取标准 国际标准化组织（ISO）: www.iso.ch 电子电气工程学会（IEEE）：www.ieee.org 美国国家标准学会（ANSI）：www.ansi.org 国际工程协会（IEC）：www.iec.org 信息技术标准国家委员会（NCITS）：www.ncits.org 美国计算机协会（ACM）：www.acm.org "},"page/1043.html":{"url":"page/1043.html","title":"通用代码审查清单","keywords":"","body":"通用代码审查清单 1、数据引用错误 数据引用错误是指使用未经正确声明和初始化的变量、常量、数组、字符串或记录而导致的软件缺陷。数据引用错误是缓冲区溢出的主要原因。 2、数据声明错误 数据声明缺陷产生的原因是不正确地声明或使用变量和常量。 3、计算错误 计算或运算错误就是计算无法得到预期的结果。 4、比较错误 在使用比较和判断运算时产生的比较和判断错误，这种错误很可能是因为边界条件问题。 5、控制流程错误 控制流程错误产生的原因是编程语言中循环等控制结构未按预期的方式工作。通常由计算或者比较错误直接或间接造成。 6、子程序参数错误 子程序参数错误的来源是软件子程序不正确地传递数据。 7、输入/输出错误 输入输出错误包括文件读取、接受键盘或鼠标输入，以及向打印机或屏幕等输出设备写入错误。 8、其他检查 "},"page/1044.html":{"url":"page/1044.html","title":"动态白盒测试方法","keywords":"","body":"动态白盒测试方法 动态白盒测试主要是按一定步骤和方法生成测试用例，并驱动相关模块去执行程序并发现软件中的错误和缺陷。 测试人员要求对被测系统内的程序结构有深入的认识，清楚程序的结构、各个组成部分及其之间的关联，以及其内部的运行原理、逻辑等。 内容包括的4部分： （1）直接测试底层函数、过程、子程序和库。 （2）以完整程序的方式从顶层测试软件，有时根据对软件运行的了解调整测试用例。 （3）从软件获得读取变量和状态信息的访问权，以便确定测试结果与预期结果是否相符，同时强制软件以正常测试难以实现的方式运行。 （4）估算执行测试时“命中”的代码量和具体代码，然后调整测试，去掉多余的测试用例，补充遗漏的测试用例。 "},"page/1045.html":{"url":"page/1045.html","title":"逻辑覆盖法","keywords":"","body":"逻辑覆盖法 ​ 逻辑覆盖法是动态白盒测试中常用的测试技术，是一系列测试过程的总称。有选择地执行程序中的某些最具有代表性的通路来对尽穷测试的唯一可行的替代方法。 ​ 逻辑覆盖法的覆盖率是程序中一组被测试用例执行到的百分比。 覆盖率=（至少被执行一次的被测试项数）/被测试项总数 ​ 根据测试覆盖的目标不同，以及覆盖的程度不同，可由弱到强分为：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、修正的判定/条件覆盖、条件组合覆盖、路径覆盖。 "},"page/1046.html":{"url":"page/1046.html","title":"1、语句覆盖和块覆盖","keywords":"","body":"1、语句覆盖和块覆盖 ​ 语句覆盖又称为代码行覆盖，指选择足够多的测试用例，使得程序中的每一条可执行语句至少被执行一次。 ​ 程序的基本块就是一个连续的语句序列，只有一个入口点和一个出口点。这些唯一的入口点和出口点就是基本块的第一条语句和最后一条语句。程序的控制总是从基本块的入口点进入，从出口点退出。除了其出口点，程序不可能在基本块的其他任意点退出或中止。 例3-1 下面以一个简单的小程序段来说明怎样设计测试用例。 Void testexample1(int x,int y,int z) { if (x>1)&&(y==0) z=z+x; if (x==2)||(z>1) z=z+y; return z; } 对于这段testexample1函数相对应的程序控制流程图见图3-7所示。 图3-7例3-1的模块的流程图(图中数字1，2，3，4，5，6，7为边) 对于testexample1函数，完全语句覆盖是从第1行执行到最后一行。因此它的测试用例的设计见表3-1： 表3-1 testexample1语句覆盖测试用例 | ID | 输入数据 | 输入数据 | 输入数据 | 返回值 | 通过的路径 | | ------- | -------- | -------- | -------- | ------ | ---------- | | ID | x | y | z | z | | | TE1-001 | 2 | 0 | 4 | 6 | 1-4-5-6-7 | 对于testexample1函数，其函数体可以分为五个块，第一块为第一个if语句；第二块为赋值语句z=z+x；第三块为第二个if语句；第四块是赋值语句z=z+y；第五块是 return z语句。将图3-7换为图3-8所示。 图3-8 testexample1函数体的控制流图 ​ 块覆盖的测试用例的设计是要将这五块都要遍历，表3-1语句覆盖的测试用例也就是这个函数的块覆盖的测试用例。注意，语句覆盖是覆盖所测试程序段中的所有语句，块覆盖是测试程序段中的所有基本块。 "},"page/1047.html":{"url":"page/1047.html","title":"2、判定覆盖","keywords":"","body":"2、判定覆盖 ​ 判定覆盖又叫分支覆盖，即设计若干测试用例，使得程序中的每个判定表达式的每种可能的结果值都应该至少执行一次，也就是说每个判定的“真”值分支和“假”值分支都至少执行一次。 例3-2 对于testexample1函数实现判定覆盖设计的测试用例见表3-2： 表3-2 testexample1判定覆盖测试用例 ID 输入数据 返回值 通过的路径 x y z z TE1-002 2 0 4 6 1-4-5-6-7 TE1-003 3 1 1 1 1-2-3 "},"page/1048.html":{"url":"page/1048.html","title":"3、条件覆盖","keywords":"","body":"3、条件覆盖 ​ 条件覆盖是将各分支的条件考虑在内，即设计足够多的测试用例，不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果。也就是说，每个判定中的条件取“真”值和“假”值都需执行一次。 例3-3 对于testexample1函数实现判定覆盖设计的测试用例时要考虑到二个判定中的每一个条件: 第一个判定中的两个条件：条件1：x>1，条件2：y= =0考虑这两个条件分别取“真”和取“假”的情况，则有下面的几种结果出现： x>1，x 第二个判定中的两个条件：条件3：x==2，条件4：z>1考虑这两个条件分别取“真”和取“假”的情况，则有下面的几种结果出现： x=2，x≠2，z>1，z 表3-3 testexample1条件覆盖测试用例 ID 输入数据 返回值 通过的路径 x y z z TE1-004 2 0 4 6 1-4-5-6-7 TE1-005 1 1 1 1 1-2-3 从表3-3中可知，两个测试用例TE-004、 TE-005就覆盖了所有的条件结果，同时也做到了判定覆盖，但是测试用例有时满足条件覆盖并不满足判定覆盖。 "},"page/1049.html":{"url":"page/1049.html","title":"4、判定/条件覆盖","keywords":"","body":"4、判定/条件覆盖 判定/条件覆盖是设计足够多的测试用例，使得判定表达式中的每一个条件都取到各种可能的值，同时每个判定表达式也都取到各种可能的结果。 例3-4 对于testexample1函数实现判定/条件覆盖设计的测试用例见表3-3。 "},"page/1050.html":{"url":"page/1050.html","title":"5、条件组合覆盖","keywords":"","body":"5、条件组合覆盖 条件组合覆盖要求设计足够多的测试用例，使得每个判定表达式中的条件的各种组合可能都至少被执行一次。 例3-5 对于testexample1函数的两个判定，存在的所有条件组合有8种： （1）x>1，y=0 （2）x>1，y≠0 （3）x （5）x=2，z>1 （6）x=2，z1 （8）x≠2，z 根据满足所有的条件组合来设计测试用例，见表3-4。 表3-4 testexample1条件组合覆盖测试用例 输入数据 输入数据 输入数据 返回值 通过的路径 ID x y z z TE1-006 2 0 4 6 1-4-5-6-7 TE1-007 1 1 1 1 1-2-3 TE1-008 2 1 1 2 1-2-6-7 TE1-009 1 0 2 2 1-2-3 由表3-4可知，其中TE-006测试用例覆盖了条件组合中的（1）（5）， TE-007测试用例覆盖了条件组合中的（4）（8）， TE-008测试用例覆盖了条件组合中的（2）（6）， TE-009测试用例覆盖了条件组合中的（3）（7）。 "},"page/1051.html":{"url":"page/1051.html","title":"6、改进的判定/条件覆盖","keywords":"","body":"6、改进的判定/条件覆盖 ​ 一个基于改进的条件/判定覆盖概念的充分性准则又称为MC/DC覆盖，它可以对所有条件和判定进行完全且合理的测试。 ​ 满足MC/DC覆盖的测试用例要求如下： （1）每一个基本块都被覆盖了。 （2）每一个简单条件都取过真值和假值。 （3）每一个判定都得出过所有可能的输出结果。 （4）每一个简单条件对表达式的输出结果的影响是独立的。 测试用例号 输入 输入 输入 表达式值 注释 A B C 1 T T T T 固定A、B， A、B为T 2 T T F T 固定A、B， A、B为T 3 T F T T 固定A、B， A为T、B为F 4 T F F F 固定A、B， A为T、B为F 5 F T T T 固定A、B， A为F、B为T 6 F T F F 固定A、B， A为F、B为T 7 F F T T 固定A、B， A、B为F 8 F F F F 固定A、B， A、B为F 9 T T T T 固定A、C， A、C为T 10 T F T T 固定A、C， A、C为T 11 T T F T 固定A、C， A为T、C为F 12 T F F F 固定A、C， A为T、C为F 13 F T T T 固定A、C， A为F、C为T 14 F F T T 固定A、C， A为F、C为T 15 F T F F 固定A、C， A、C为F 16 F F F F 固定A、C， A、C为F 17 T T T T 固定B、C， B、C为T 18 F T T T 固定B、C， B、C为T 19 T T F T 固定B、C， B为T、C为F 20 F T F F 固定B、C， B为T、C为F 21 T F T T 固定B、C， B为F、C为T 22 F F T T 固定B、C， B为F、C为T 23 T F F F 固定B、C， B、C为F 24 F F F F 固定B、C， B、C为F 从表3-5中可以发现，其中有很多是行是重复的。针对三个条件中的每一个条件，选择其中两个测试用例来说明该简单条件对表达式结果的独立影响：对C，选择测试用例（3，4）；对B，选择测试用例（11，12）；对A，选择测试用例（19，20）。如表3-6所示，共有6个测试用例。 表3-6表达式(A and B) or C 的充分测试集 测试用例号 输入 输入 输入 表达式值 对表达值有影响的输入 A B C 1 [3] T F T T C 2 [4] T F F F C 3 [11] T T F T B 4 [12] T F F F B 5 [19] T T F T A 6 [20] F T F F A 将表3-6再进行简化得表3-7，得其最小测试集如表3-7。可知：复合条件中的每一个简单条件都独立地影响复合条件的结果。程序中每个复合条件都必须测试到。并且此覆盖比组合条件所需的测试用例数要少。对表达式(A and B) or C，在条件组合覆盖下最多需要8个测试用例，而满足MC/DC覆盖只需要4个测试用例即可。 表3-7表达式(A and B) or C 的最小充分测试集 测试用例号 输入 输入 输入 表达式值 对表达值有影响的输入 A B C 1 T F T T 2 T F F F 测试用例1、2覆盖C， 3 T T F T 测试用例2、3覆盖B， 4 F T F F 测试用例3、4覆盖A 例3-7 对于testexample1函数实现MC/DC覆盖设计测试用例如表3-8、表3-9、表3-10所示。 表3-8 testexample1函数表达式(x>1)&&(y==0)最小充分测试用例集 测试用例号 输入 表达式值 对表达值有影响的输入 x y 1 2 0 T 测试用例1、2覆盖y，测试用例2、3覆盖x 2 2 1 F 3 1 0 F 表3-9 testexample1函数表达式(x==2)||(z>1)最小充分测试用例集 测试用例号 输入 输入 表达式值 对表达值有影响的输入 x z 5 2 0 T 6 1 2 T 测试用例5、6覆盖x， 7 1 0 F 测试用例6、7覆盖z 表3-10 testexample1函数的MC/DC覆盖设计测试用例 ID 输入数据 输入数据 输入数据 返回值 对表达式有影响的输入 x y z z TE1-010 2 0 1 3 TE1-011 2 1 1 2 TE-010、 TE-011覆盖y TE1-012 1 0 2 2 TE-011、TE-012覆盖x TE1-013 1 0 0 0 TE-012、 TE-013覆盖z "},"page/1052.html":{"url":"page/1052.html","title":"7、路径覆盖","keywords":"","body":"7、路径覆盖 ​ 路径覆盖是指设计足够多的测试用例，使得程序中的所有可能的路径都至少被执行一次。例3-8 对于testexample1函数程序段，满足路径覆盖的测试用例设计如表3-11所示。 表3-11 testexample1路径覆盖测试用例 ID 输入数据 输入数据 输入数据 返回值 通过的路径 x y z z TE1-014 2 0 4 6 1-4-5-6-7 TE1-015 1 1 1 1 1-2-3 TE1-016 2 1 1 2 1-2-6-7 TE1-017 3 0 0 3 1-4-5-3 当程序中的每一条路径都受到检验，才能使程序受到较全面的检验。由表3-11可知，这段程序非常简单，只有4条路径，但在实际问题中，一个不太复杂的程序中的路径都可能是一个庞大的数字，要在测试中覆盖所有的路径是不可能实现的。为了解决这一难题，常将覆盖的路径数压缩到一定的限度内，如程序中的循环体只执行一次的情况。 "},"page/1053.html":{"url":"page/1053.html","title":"8、线性代码序列和跳转覆盖(LCSAJ)","keywords":"","body":"8、线性代码序列和跳转覆盖(LCSAJ) ​ 线性代码序列和跳转（Linear Code Sequence And Jump）是一个程序单元，它由一段有序的代码序列组成，该序列结束时会跳转到另一个代码序列开始。 ​ 一个LCSAL包含一条或多条语句，表示成三元组（X，Y，Z）,其中X、Y分别表示代码序列的第一条语句和最后一条语句，Z是语句Y要跳转到的位置。 ​ 当程序的控制到达X时，顺序执行相关语句后到达Y，然后跳转到Z。这样，就称LCSAJ（X，Y，Z）被遍历了，也称被覆盖了。 例3-9 函数testexample2的函数体只有一个条件语句。 1 Void testexample2(int x;inty) 2 { 3 int p; 4 if (x 对于这个函数体中的LCSAJ见下表3-12所示。 表3-12 testexample2函数体中的LCSAJ LCSAJ 开始行号 结束行号 跳转到 1 3 6 return 2 3 4 7 3 7 8 return 根据表3-12中的测试用例使得表3-13中的三个LCSAJ各被遍历了至少一次。 表3-13 testexample2 LCSAJ覆盖测试用例 ID 输入数据 输入数据 返回值 LCSAJ x y p TE2-001 2 8 8 1 TE2-002 6 3 6 2,3 "},"page/1054.html":{"url":"page/1054.html","title":"基本路径法","keywords":"","body":"基本路径法 ​ 基本路径测试是T.McCabe（音译：麦凯伯）首先提出的一种白盒测试技术。所谓基本路径是指程序中至少引进一条新的语句或一个新的条件的任一路径。 ​ 基本路径测试法又称独立路径测试，是在程序控制流图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，从而设计出相应的测试用例的方法。 基本路径测试的基本步骤为： （1）根据程序设计结果导出程序流程图的控制流图； （2）计算程序的环路复杂度； （3）导出基本路径集，确定程序的独立路径； （4）根据独立路径，设计相应的测试用例。 例3-10 对于testexample1函数程序段，首先将其控制流图3-7修改成判定框单一条件，见图3-9所示。然后导出图3-9对应的流图，见图3-10所示。 第二步，计算程序环路复杂度。 计算环形复杂度可以直接计算程序流程图中判定数量（每个判定是单一条件的），然后加1即可得到。 从图3-9可以有4个判定框，所以环路复杂度为5。 利用公式：V(G)=e-n+1计算，其中e为图G中的边数，n为图G中的结中数 （注意：要变成强连通图，要增加一条从出口到入口的边）。 V（G）=13-9+1=5。 按区域数计算环形复杂数，图3-10中有4个小区域，加上图形外一个区域，共有5个，因此环形复杂度为5。 也可采用图形矩阵方法来计算。见图3-11所示，根据图形矩阵图各点之间的连接权数减1后的和，再加1得到环形复杂数为5。 第三步，确定独立路径集。因为环形复杂数为5，所以有5条基本路径 ： path1：1—2—4—5—6—7 path2：1—2—3—4—5—6—7 path3：1—2—3—8—4—5—6—7 path4：1—2—3—8—4—5—9—7 path5：1—2—3—8—4—5—6—9—7 第四步，设计测试用例。根据前面确定的独立路径集，设计测试用例及其输出。见表3-14。 表3-14 testexample1基本路径覆盖测试用例 ID 输入数据 输入数据 输入数据 返回值 通过的路径 x y z z TE1-014 1 0 1 1 Path1 TE1-015 3 1 1 1 Path2 TE1-016 3 0 3 6 Path3 TE1-017 2 0 2 4 Path4 TE1-018 3 0 6 9 Path5 "},"page/1055.html":{"url":"page/1055.html","title":"循环测试","keywords":"","body":"循环测试 循环测试是一种白盒测试技术，专注于测试循环结构的有效性。 它遵循的基本测试原则是：在循环的边界和运行界限执行循环体。 在结构化的程序中，循环结构通常只有三种：简单循环、串接循环和嵌套循环。 其它不规则的循环结构都可以转化这三种结构。 "},"page/1056.html":{"url":"page/1056.html","title":"1、简单循环的测试","keywords":"","body":"1、简单循环的测试 1、简单循环的测试假设循环体执行的最大次数为n，在测试时，我们需要考虑的几情况： （1）零次循环：不执行循环体，直接退出； （2）一次循环：只执行一次循环体； （3）二次循环：执行二次循环体； （4）m次循环：执行循环体m次（m （5）n-1次循环：执行循环体n-1次； （6）n次循环：执行循环体n次； （7）n+1次循环：执行循环体n+1次。 例3-11 一段简单的程序代码。 Void testexample3(int n) { int i; int sum=0; for (i=1;i 调用此函数时，设n=10。则对这段循环程序进行测试用例的设计见表3-15 表3-15 testexample3简单循环测试用例 ID 循环取值 初始值 返回值 执行循环次数 n i sum TE3-001 0 1 0 0 TE3-002 1 1 1 1 TE3-003 2 1 3 2 TE3-004 5 1 15 5 TE3-005 9 1 45 9 TE3-006 10 1 55 10 TE3-007 11 1 66 11 "},"page/1057.html":{"url":"page/1057.html","title":"2、嵌套循环的测试","keywords":"","body":"2、嵌套循环的测试 （1）B.Beizer提出了一种能减少测试数的方法 从最内层循环开始测试，把所有其他循环都设置为最小值； 对最内层循环使用简单循环测试方法，而使外层循环的迭代参数（例如，循环计数器）取最小值，并为越界值或非法值增加一些额外的测试； 由内向外，对下一个循环进行测试，但保持所有其他外层循环为最小值，其他嵌套循环为“典型”值； 继续进行下去，直到测试完所有循环。 （2）对于嵌套循环的测试重点注意事项 当外循环变量为最小值时，内层循环为最小值和最大值时的运算结果。 当外循环变量为最大值时，内层循环为最小值和最大值时的运算结果。 循环变量的增量是否正确。 何时退出循环。 "},"page/1058.html":{"url":"page/1058.html","title":"3、串接循环的测试","keywords":"","body":"3、串接循环的测试 串接循环又称为并列循环。如图3-14所示。 在对串接循环进行测试时，如果串接循环的各个循环都彼此独立，则可以使用前述的简单循环测试方法来测试串接循环。 如果两个循环串接，而且第一个循环的循环计数器值是第二个循环的初始值，则这两个循环并不是独立的。 当循环不独立时，建议使用嵌套循环测试方法来测试串接循环。 "},"page/1059.html":{"url":"page/1059.html","title":"数据流测试","keywords":"","body":"数据流测试 数据流的基本概念 （1）变量的定义和使用 变量一般通过赋值来定义和初始化，并在表达式中被使用。 （2）c-use 和p-use 如果一个变量被用在赋值语句的表达式、输出语句中，或者被当作参数传递给调用函数，或者被用在下标表达式中，都称为该变量的c-use。其中c表示“计算”。 如果一个变量被用在分支语句的条件表达式中，则称为变量的p-use。其中p表示“谓词”。 （3）全局和局部的定义与使用 一个变量可能在同一个基本块中被定义、使用和重定义。 注：我们只关心全局变量的定义和使用，局部定义与使用在研究基于数据流的测试时没有意义。 数据流图 ​ 程序的数据流图（DFG）又称def-use图，它勾画了程序中变量在不同的基本块间的定义流。与程序的控制流图（CFG）有点相似，并可以从它的CFG中导出。 例3-12 ：考虑如下一个基本块，包含两条赋值语句和一个函数调用语句。 P=y+z; Foo(p+q,number); A[i]=x+1; If (x>y) {…} 从此基本块中可知，def={p,A}，c-use={y,z,p,q,number,x,i}，p-use={x,y}。 构造数据流图基本过程： （1）计算程序中每个基本块的def 、c-use和p-use。 （2）将结点集中的每个结点与它对应的def 、c-use和p-use关联起来。 （3）针对每个具有非空p-use集并且在条件C处结束的结点，如果条件C为真时执行的边1，C为假时执行的是边2，分别将边1、边2与C，！C关联起来。 例子 "},"page/1062.html":{"url":"page/1062.html","title":"def-clear路径","keywords":"","body":"3、def-clear路径 一个数据流图可以有许多路径，其中有一类路径就是def-clear路径。 假设变量x在结点i中定义，在结点j中使用，对于路径p={i，n1，n2，…，nk，j}，k≥0，并且结点i、j在子路径n1，n2，…，nk中未出现过，变量x没有在子路径中被重新定义，称p是变量x的def-clear路径。 例子 "},"page/1063.html":{"url":"page/1063.html","title":"def-use对","keywords":"","body":"4、def-use对 对任一变量x，从被定义开始到其被使用就构成了此变量的一次特定的def-use对 有两类型的def-use对： 一种是定义及其c-use构成的def-use对 另一种是定义及其p-use构成的def-use。分别用集合dcu和dpu来描述这两类def-use对。 例子 "},"page/1064.html":{"url":"page/1064.html","title":"def-use链","keywords":"","body":"5、def-use链 def-use对的概念可以扩展成变量的一个交替出现的定义、使用序列，这种序列也称为def-use链或k-dr交互。def-use链中的结点各不相同；其中k-dr,k表示链的长度（链中结点的个数，比def-use对的个数多1），字母d表示“定义”，字母r表示“引用”。 例子 "},"page/1065.html":{"url":"page/1065.html","title":"优化","keywords":"","body":"6、优化 经过简单分析数据流图可以减少要覆盖的def-use对个数。 从图3-15知，覆盖了dcu(z，1)意味了覆盖了dcu(x，1)和dcu(y，1)。因为覆盖变量z在结点2中的c-use必须遍历路径（1，2），覆盖了dcu(x，1)；覆盖变量z在结点4中的c-use必须遍历路径（1，3，4），覆盖了dcu(y，1)；用类似的分析方法，可以将c-use覆盖减少到最小集。见表3-18所示。 表3-18 "},"page/1060.html":{"url":"page/1060.html","title":"数据流的测试用例设计","keywords":"","body":"数据流的测试用例设计 假设程序P的数据流图包含K个结点，n1，nk分别表示开始结点和结束结点。当针对测试用例T执行程序P时，如果遍历了完整路径（ni1,ni2…nim），则称程序P数据流图中的结点S被测试用例T覆盖了。其中，s=nij，1≤j≤m，m≤k。 同样，当针对测试用例T执行程序p时，如果遍历了上述路径，则称程序p数据流图中的边（r，s）被测试用例T覆盖了。其中r、s为上述路径中相邻的两结点。 c-use覆盖 设z是dcu(x,q)中的一个结点，即结点z包含在结点q处定义的变量x的一个c-use ，假设针对测试用例tc执行程序P，遍历了如下完整路径： P=(n1,ni1,…nil,nil+1…nim,nim+1,…,nk) 其中，2≤ij≤k，1≤j≤k。 如果q=ni1，s=nim，( nil+1…nim)是一个从q到z的def-use路径，则称变量x的该c-use被覆盖。如果dcu(x,q)中的每一个结点在程序P的一次或多次执行中都被覆盖，则称变量x的所有c-use被覆盖。如果程序P中所有的变量的所有的c-use都被覆盖了，则称程序中所有的c-use被覆盖。 例子 p-use覆盖 设（z，r），（z，s）是dpu（x，q）中的两条边，即结点z包含变量x的一个p-use，x是在结点q中定义的。假设针对测试用例tp执行程序p，遍历了如下完整路径： P=(n1,ni1,…nil,nil+1…nim,nim+1,…,nk) 其中，2≤ij≤k，1≤j≤k。 如果下面的条件满足了，则称结点q定义的变量x在结点z的p-use的边（z，s）被覆盖：q=nij,z=nim,r=nim+1，并且（nil，nil+1，…，nim，nim+1）对x而言是一个def-clear路径。 类似地，如果下面的条件满足了，则称结点q定义的变量x在结点z的p-use的边（z，r）被覆盖：q=nij,z=nim,s=nim+1，并且（nil，nil+1，…，nim，nim+1）对x而言是一个def-clear路径。 当程序p的同一次或多次执行中满足上述两个条件时，则称变量x 在结点z的p-use被覆盖。 例子 all-use覆盖 当所有的c-use和p-use都被覆盖时，就认为满足all-use覆盖。 "},"page/1061.html":{"url":"page/1061.html","title":"白盒测试运用实例","keywords":"","body":"白盒测试运用实例 问题 画出流程图 C++源程序 逻辑测试方法 语句覆盖 判定覆盖 条件覆盖 判定/条件覆盖 修正的判定/条件覆盖 条件组合覆盖 路径覆盖 "},"page/1023.html":{"url":"page/1023.html","title":"黑盒测试","keywords":"","body":"黑盒测试 黑盒测试运用实例 题目 1、边界值测试 2、等价类划分法测试 3、决策表法测试 黑盒法综合策略 （1）首先用边界值分析法设计测试用例； （2）必要时用等价分类法补充测试用例； （3）必要时再用猜错法补充测试用例； （4）如果在程序的说明中含有输入条件的组合，宜在一开始末就采用因果法，然后再按上述步骤进行。 "},"page/1066.html":{"url":"page/1066.html","title":"黑盒测试基本概念","keywords":"","body":"黑盒测试基本概念 定义 黑盒测试又称为功能测试或数据驱动测试。 由于此方法不需要了解程序的内部逻辑结构和内部特性，将被测试程序视为一个不能打开的黑盒子；而是注重于程序的外部结构，主要对软件功能要求、软件界面、外部数据库访问及软件初始化等方面进行测试。 测试者只要从程序接口处进行测试，以程序需求说明为测试依据，测试程序是否满足用户的需求，因此是从用户观点出发的测试。 黑盒测试主要发现的错误类型 （1）检测功能是否有遗漏； （2）检测性能是否满足要求； （3）检测人机交互是否有错误； （4）检测界面是否有错误； （5）检测数据结构或外部数据库访问是否有错误； （6）检测接收数据和结果输出是否错误； （7）检测程序初始化和终止方面是否有错误。 黑盒测试的依据 黑盒测试也称为功能测试、行为测试或数据驱动测试，在测试时，把程序看作一个不能打开的黑盒，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。 黑盒测试主要检查内容 （1）正确性：计算结果，命名方面。 （2）可用性：是否可以满足软件的需求说明。 （3）边界条件：输入部分的边界值。 （4）性能：程序的性能取决于两个因素：运行速度的快慢和需要消耗的系统资源。 （5）压力测试：多用户情况可以考虑使用压力测试工具，建议将压力和性能测试结合起来进行。如果有负载平衡的话还要在服务器端打开检测工具，查看服务器CPU使用率，内存占用情况，如果有必要可以模拟大量数据输入，对硬盘的影响等等信息。 （6）错误恢复：错误处理，页面数据验证，包括突然间断点，输入错误数据等。 （7）安全性测试：对系统的安全进入、安全操作及相关权限进行测试。特别是一些商务网站，或者跟钱有关，或者和公司秘密有关的web更是需要这方面的测试。 （8）兼容性：不同浏览器，不同应用程序版本在实现功能时的表现。 黑盒测试的流程 1、测试计划 2、测试设计 3、测试开发 4、测试执行 5、测试评估 黑盒法综合策略 （1）首先用边界值分析法设计测试用例； （2）必要时用等价分类法补充测试用例； （3）必要时再用猜错法补充测试用例； （4）如果在程序的说明中含有输入条件的组合，宜在一开始末就采用因果法，然后再按上述步骤进行。 "},"page/1067.html":{"url":"page/1067.html","title":"黑盒测试方法","keywords":"","body":"黑盒测试方法 根据一些相关条件和方法对较典型的测试用例进行测试，来发现软件中存在的缺陷。现在大多数测试生成方法，都是通过选取软件输入域的一个子集作为测试集来测试软件的。 黑盒测试常用的方法和技术有： 等价类划分法、边界值分析法、决策表法、因果图法等。 黑盒法综合策略： （1）首先用边界值分析法设计测试用例； （2）必要时用等价分类法补充测试用例； （3）必要时再用猜错法补充测试用例； （4）如果在程序的说明中含有输入条件的组合，宜在一开始末就采用因果法，然后再按上述步骤进行。 "},"page/1068.html":{"url":"page/1068.html","title":"等价类划分法","keywords":"","body":"等价类划分法 等价类划分法是根据程序规格说明书对输入范围进行划分，将所有可能的输入数据按相关的规定划分成若干不相交的子集。所有子集的并集是整个输入域。其中，子集的互不相交保证子集中无冗余性，子集的并集是整个输入域，确定了所有子集的完备性。 缺陷的定位 一个软件的全部输入的集合可以至少分为两个子集：一个包含所有正常和合法的输入；另一个包含所有异常和非法的输入。对于这两个子集又可以进一步划分为若干子集，以便软件针对不同的子集，其运行的结果不同。等价类划分方法就是要从这两个集合或其子集中选择适当的输入作为测试用例，以便发现软件中存在的缺陷。 等价类的划分 等价类划分的原则是用同一等价类中的任意输入对软件进行测试，软件都输出的相同的结果。全部等价类的测试用例就构成了完整的测试用例集。对于同一输入域进行等价类划分，其结果可能不唯一的。因此，利用等价类划分的方法产生的测试用例集也可能不同。所以测试用例集的故障检测效率往往取决于测试人员的测试设计的经验、对软件需求的熟悉程序等。 （1）划分等价类 在划分等价类时，分为有效等价类和无效等价类。有效等价类是指符合程序规格说明书，有意义的、合理的输入数据所构成的集合。有效等价类可以是一个，也可以是多个。利用有效等价类，可以检查软件功能和性能是否符合规格说明书中的要求。无效等价类是指不符合程序规格说明书、不合理或无意义的输入数据所构成的集合。可以是一个，也可以是多个。利用无效等价类，可以检查软件功能和性能的实现是否有不符合规格说明书的地方。 （2）常用的等价类划分原则 ①变量的等价类划分 取值范围：如果输入条件规定了一个取值范围或值的个数，则可以定义一个有效等价类和两个无效等价类。字符串：至少分为一个包含所有合法字符串的有效等价类和一个包含所有非法字符串的无效等价类。枚举变量：每个取值对应一个有效等价。针对枚举类型，对于某些特定的取值范围，有可能无法确定非法测试输入值。对于布尔变量，只有两个合法取值（真值与假值）。数组：数组是一组具有相同类型的元素的集合，数组的长度及其类型都可作为等价类划分的依据。可划分为一个包含所有数组的有效等价类，一个空数组无效等价类，以及一个包含所有大于期望长度数组的无效等价类。复合数据类型：复合数据类型是指包含两个或两个以上的相互独立的属性的输入数据。当对软件的一个组件模块（函数或对象）进行测试时，将使用这种输入类型。对这种复合数据类型的输入进行等价类划分时，需要考虑输入数据的每个属性的合法与非法取值。 ②关系与等价类划分 在集合论中，关系指的是一个n元组的集合。如果规定了输入值的集合，或者规定了“必须如何”的条件，则可以定义一个有效等价类和一个无效等价类。如果规定了输入数据的一组值，而且程序对不同输入值做不同处理，则可以定义若干有效等价类（每个值一个有效等价类）和一个无效等价类。如果规定了输入数据必须遵守的规则，则可以定义一个有效等价类（符合规则）和若干无效等价类（从不同角度违反规则）。 ③一元化分与多元化分 一元化等价类划分：每次只考虑一个输入变量，这样，每个输入变量形成了对输入域的一个划分，称为一元等价类划分，简称一无化分。程序有多少个变量，就有多少种划分，每个划分包含两个或两个以上的等价类。多元划分：将所有输入变量的笛卡儿积作为程序的输入域，称为多元等价类划分，简称多元化分。此方法只产生一个划分，划分包含若干个等价类。测试用例的选择常使用一元化分，因为一元化分较为简单且可量测。而多元化分所产生的等价类数量较大，并且其中有许多是无用的。 （3）划分等价类的步骤 确定输入域：分析需求并确定所有的输入、输出量，以及变量类型和变量使用条件。等价类划分：将每个变量的取值集合划分为互不相交的子集，每个子集对应一个等价类，所有的等价类就构成了对输入域的一个划分。组合等价类：使用多元化方法，可以将等价类组合起来。确定不可测的等价类：有些输入数据组合在实际测试过程中是无法生成的，包含这种数据的等价类就是不可测试等价类。不可测试数据指无法输入到被测软件中的那些数据组合。 （4）等价类的测试步骤 ①划分等价类，形成等价类表； ②为每个等价类规定一个唯一的编号； ③设计一个新的测试用例，使其尽量多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止。 ④设计一个新的测试用例。使其覆盖一个而且只覆盖一个无效等价类，重复这一步，直到所有无效等价类均被覆盖为止。 基于等价类的测试用例设计 例4-1 对热水器温控软件划分等价类并设计测试用例 题目 步骤1：确定输入域 步骤2：等价类划分 步骤3：组合等价类 由表4-2中可知，变量V，F，cmd，tempch代表的集合分别补划分成3个、2个、4个、5个子集，因此这4个变量共形成3×2×4×5=120个等价类，其中有些是不可测等价类 步骤4：剔除不可测等价类 步骤5：根据可测等价类设计测试用例 例4-2 三角形问题的等价类测试 "},"page/1069.html":{"url":"page/1069.html","title":"边界值分析法","keywords":"","body":"边界值分析法 边界值分析方法概述 边界值分析法主要从数据的定义域的边界数据进行分析，对于合法与不合法的边界数据进行选取和测试。用来检查用户输入的信息、返回的结果以及中间计算结果是否正确。 边界值的获取及测试用例的设计 测试时输入变量取值：最小值(min)、略高于最小值(min+)、正常值(nom)、略低于最大值(max-)、最大值(max)。 对于一个含有n个变量的程序，保留其中一个变量，让其余的变量取正常值，被保留的变量依次取最小值(min)、略高于最小值(min+)、正常值(nom)、略低于最大值(max-)、最大值(max)，对每一个变量都重复进行。因此，对于一个有n个变量的程序，边界值分析测试程序就有4n+1个测试用例。 测试所包含的边界值常见的类型有：数值、字符、位置、大小、尺寸、空间等。 边界值的获取及生成测试用例的步骤 （1）使用一元划分方法划分输入域。此时，有多少个输入变量就形成多少种划分。 （2）为每种划分确定边界，也可利用输入变量之间的特定关系确定边界。 （3）设计测试用例，确保每个边界至少出现在一个测试输入数据中。 健壮性的测试 健壮性测试是边界分析测试的一种扩展，除了取上面已述的五种边界值外，还要考虑超出范围的值，即比最小值要小（min-）、比最大值要大（max+）的取值。对于一个含有n个变量的程序而言，同样，保留一个变量，让其余变量取正常值，这个保留的变量依次取七个值（min-、min、min+、nom、max-、max、max+），每个变量重复进行，则健壮性测试的用例将产生6n+1个测试用例。 边界分析法的测试用例 例4-3 例4-4 "},"page/1070.html":{"url":"page/1070.html","title":"决策表法","keywords":"","body":"决策表法 决策表又称为判定表，是分析和表达多逻辑条件下执行不同操作的情况的工具。能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏，设计出完整的测试用例集合。在所有功能性测试方法中，基于决策表的测试方法是最严格的测试方法之一。 决策表的组成： 由条件桩、动作桩、条件项和动作项四个部分组成。 条件桩：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。动作桩：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。条件项：列出针对它左列条件的取值。在所有可能情况下的真假值。动作项：列出在条件项的各种取值情况下应该采取的动作。规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。 决策表的类型 有限条目决策表：所有条件都是二叉条件(真/假) 。 扩展条目决策表：条件可以有多个值 。 决策表的建立步骤 构造决策表的5个基本步骤： （1）列出所有的条件桩和动作桩。 （2）确定规则的个数。 （3）填入条件项。 （4）填入动作项，得到初始决策表。 （5）合并相似规则，得到优化决策表 决策表的测试用例 例4-5 "},"page/1071.html":{"url":"page/1071.html","title":"因果图法","keywords":"","body":"因果图法 因果图方法概述 因果图，也称作依赖关系模型。主要用于描述软件输入条件（原因）与软件输出结果（结果）之间的依赖关系。“原因”是指软件需求中能影响软件输出的任意输入条件。“结果”是指软件对某些输入条件的组合所做出的响应。可以是一条提示信息，也可以是弹出的一个新窗口，还可以是数据库的一次更新。结果可以可见或不可见。 因果图法特别适用于被测程序具有多种输入条件，程序的输出又依赖于输入条件的各种组合的情况。因果图方法最终生成的就是判定表。 因果图中的基本符号和约束 在图果图有两种类型的符号： (1)因果关系符号有：对应关系、否定关系、选择关系和并列关系； (2)约束关系符号有：互斥关系、包含关系、唯一关系、要求关系和屏蔽关系； 因果图中的基本符号与约束关系见表4-17所示： 因果图测试用例的设计步骤 （1）分析程序规格说明中哪些是原因，哪些是结果。原因常常是输入条件或输入条件的等价类，结果则是输出条件。 （2）分析程序规格说明中描述内容的语义和限制，找出两类关系，画出因果图。 （3）把因果图转换成判定表。 （4）对判定表的每一列写成一个测试用例。 因果图法的测试用例 "},"page/1072.html":{"url":"page/1072.html","title":"其他黑盒测试方法","keywords":"","body":"其他黑盒测试方法 "},"page/1073.html":{"url":"page/1073.html","title":"1、类别划分法","keywords":"","body":"1、类别划分法 （1）类别划分法概述 类别划分法是一种从软件需求生成测试用例的系统化的方法。该方法同时可以包含手工和自动完成的步骤。类别划分法的本质是测试人员将软件需求转换为相应的测试规范，其中，测试规范由对应于软件输入变量和环境对象的各种类别构成。 每个类别被划分为若干个对应于软件输入变量、环境对象状态的一个或多个取值的选项。测试规范中同时也包含了各选项之间的关系，以便确保生成合理、有效的测试集。将编写好的测试规范输入测试框架生成器，获得相应的框架，再根据测试框架可生成相应的测试脚本。 （2）类别划分的步骤 类别划分法分为8个步骤 其中实线矩形是人工完成，虚线矩形框是自动完成。 "},"page/1074.html":{"url":"page/1074.html","title":"2、谓词测试","keywords":"","body":"2、谓词测试 （1）谓词测试概述 规则可以形式化地表示为谓词。例如，考虑软件需求“若打印机处于ON状态且具备打印纸，则发送要打印的文件”。这需求中包含一个条件和一个动作。而条件是一个关系表达式，即打印机在打印状态和有打印纸存在。可以表示为P： P：(printer_status=ON)∧(printer_tray=¬empty) 这是一个谓词P，它是由布尔运算符“∧”连接的关系表达式。编程人员可能正确地为这个谓词编码，也可能没有正确编码。 根据谓词产生测试用例，来测试程序中的错误，从而可以确保在测试中发现某种类型的所有缺陷。这种用于验证谓词实现是否正确的测试称为谓词测试。 （2）谓词测试中的故障类型 一个条件可以表示成简单谓词或复合谓词。简单谓词就是一个布尔变量或关系表达式，其中变量可能取非。复合谓词可以是一简单谓词，或是由若干简单谓词或其补通过二元布尔运算符连接起来的式子。 谓词测试，主要关注三类故障：布尔运算符故障、关系运算符故障、算术表达式故障。 （3）谓词测试准则 BOR：对于复合谓词P，如果测试集T确保能够检测出P实现中存在的单/多布尔运算符故障，则T满足了BOR测试准则。称T为BOR充分测试集。 BRO：对于复合谓词P，如果测试集T确保能够检测出P实现中存在的单/多布尔运算符及关系运算符故障，则T满足了BRO测试准则。称T为BRO充分测试集。 BRE:对于复合谓词P，如果测试集T确保能够检测出P实现中存在的单/多布尔运算符、关系表达式及算术表达式故障，则T满足了BRE测试准则。称T为BRE充分测试集。 "},"page/1075.html":{"url":"page/1075.html","title":"3、错误推测法","keywords":"","body":"3、错误推测法 基本思想是：利用直觉和经验推测软件系统中可能出错的类型，列举出程序中所有可能的错误和容易发生错误的情况，用清单的形式表示，然后，再根据清单来编写测试用例。 常从以下几个方面来推测软件件系统中存在的错误： (1)软件产品以前版本中已存在的未解决的问题； (2)因为编程语言、操作系统、浏览器等环境的限制而出现的问题； (3)因模块间关联的测试出现的缺陷，修复后可能带来其他的问题等。 "},"page/1076.html":{"url":"page/1076.html","title":"黑盒测试与白盒测试的比较","keywords":"","body":"黑盒测试与白盒测试的比较 白盒测试的优缺点 优点：迫使测试人员去了解软件的实现，检测代码中的每条路径和分支，揭示隐藏在代码中的错误，对代码的测试进行比较彻底。有一定的充分性度量手段，可生成较多工具支持。 缺点：不易生成测试数据，无法对未实现规格说明的部分进行测试，工作量大,通常只用于单元测试,有应用局限性。白盒测试投入较大，成本较高。 白盒测试不验证需求规格的正确性， 无法检查代码中遗漏的路径和数据敏感性错误。 黑盒测试的优缺点 优点：对较大的代码单元来说，黑盒测试比白盒测试的效率高 ，测试人员不需要了解实现得细节，包括特定的编程语言 ，测试人员和编程人员是相互独立的，从用户的角度进行测试，很容易被接受和理解， 有助于暴露任何与规格不一致或者歧异的地方， 测试用例可以在规格完成后马上进行。 缺点：不能测试程序内部特定部位，如果程序未执行的代码，这些代码得不到测试，则无法发现错误。若没有清晰的和简明的规格，测试用例很难被设计，不易进行充分性测试。 黑盒测试与白盒测试的比较 1、测试依据不同 2、适应范围不同 3、测试方法不同 4、测试人员不同 5、测试内容及发现的错误不同 "},"page/1024.html":{"url":"page/1024.html","title":"灰盒测试","keywords":"","body":"灰盒测试 "},"page/1028.html":{"url":"page/1028.html","title":"测试阶段","keywords":"","body":"测试阶段 "},"page/1029.html":{"url":"page/1029.html","title":"单元测试","keywords":"","body":"单元测试 ​ 单元测试又称模块测试，是对已实现软件的最小单元进行测试，发现其中存在的软件缺陷，以保证构成软件的各个单元质量。这些最小单元可以一个类、一个函数或一个子程序。 单元测试的任务 ​ 单元测试是检查每个模块是否能正确实现详细设计说明书中的功能、性能、接口和其他设计约束要求，确保每个单元都能被正确地编码。通过单元测试后，要达到一定的目标： （1）该单元能否完成其特定的功能和性能。 （2）该单元的运行能否满足特定的逻辑覆盖。 （3）在运行该单元时，其内部的数据能否保持完整性。包括全局变量的处理、内部数据的形式、内容及相互关系等不出现错误。 （4）对符合要求和不符合要求的数据能否能处理，在数据边界条件上，能否正常运行。 （5）对该单元中发生的错误，是否采处有效的处理措施。 主要任务如下 1、模块的接口 2、局部数据结构 3、重要的执行路径 4、错误处理 5、边界问题 单元测试的环境 驱动模块与桩模块的概念 驱动模块（driver）是一种用于模拟被测试模块的上一级模块，相当于被测模块的主程序。主要用来接收测试数据，将相关数据传送给被测试模块，并调用被测试模块，打印执行结果。设计驱动模块的目的就是为了访问类库的属性和方法，检测类库的功能是否正确。 桩模块(存根模块)（Stub）是模拟被测试模块所调用的模块，它不是软件产品的组成部分。在集成测试前要为被测模块编制一些模拟其下级模块功能的“替身”模块，以代替被测模块的接口，接受或传递被测模块的数据，这些专供测试用的“假”模块称为被测试模块的桩模块。 单元模块测试环境 驱动模块与桩模块的设计 驱动模块满足的条件： （1）必须能驱动被测试模块的执行。 （2）能够接收要传递给被测试模块的各项参数，判断其正确性；并将正确的接收数据传送给被测试模块。 （3）能接收到被测试模块的执行结果，并对结果的正确性进行判断。 （4）能将判断结果作为测试用例结果并输出测试报告。 桩模块满足的条件： （1）被测试模块必须调用桩模块。 （2）桩模块必须能正确地接收来自被测试模块传递的各项参数，并对参数进行正确性判断，并返回执行结果。 （3）桩模块对外的接口的定义必须与被测试模块调用模块的接口一致。 假设要对某个系统的部分功能（包括4个模块A、B、C、D）进行测试，其功能分解如图所示： 某系统部分功能分解图 若采用非渐进测试方法，那么每一个测试模块都必须设计一个驱动模块，对于桩模块的设计，由具体的系统来决定。如：在这个实例中，被测模块A需要设计二个桩模块分别代替B和C模块，而被测模块B只要设计一个桩模块来代替D模块，被测模块C、D不需设计桩模块。 有根结点需要驱动，有叶结点要存根 若采用非渐进测试方法，那么每一个测试模块都必须设计一个驱动模块，对于桩模块的设计，由具体的系统来决定。如：在这个实例中，被测模块A需要设计二个桩模块分别代替B和C模块，而被测模块B只要设计一个桩模块来代替D模块，被测模块C、D不需设计桩模块。 若采用渐增式测试方法，不同渐增方式设计的驱动模块和桩模块也不同。对于采用“自顶向下”的模块测试方法，即测试模块的顺序为：A、B、C、D，那么只要设计一个驱动模块（即测试A模块的驱动模块），其它被测模块的驱动模块用它的上一层模块（已测）作为驱动模块；而设计桩模块就多了，与非渐进测试方法一样。对于采用“自底向上”的方法，测试模块的顺序是：D、C、B、A。对于每一个被测试模块都需要设计一个驱动模块，而不需要设计桩模块，各个被测模块的桩模块用已被测试的下层模块直接代替即可。在测试时也可以采用二种方式相结合的方法。 单元测试的过程 ​ 单元测试一般由编程人员完成，测试人员可以辅助开发人员进行单元测试。 ​ 具体过程分为：测试计划阶段、测试设计阶段、测试执行阶段和生成测试报告。 1、测试计划阶段 根据被测软件的详细设计说明书、代码及测试任务书，对被测单元进行分析，并确定如下内容： （1）确定被测试单元的目标、范围和约束条件。 （2）确定被测软件采用的覆盖程度及覆盖的方法和技术。 （3）确定被测单元的环境，包括软件、硬件、网络、人员配备等。 （4）确定被测单元的测试结束的要求。 （5）确定单元测试活动的进度。 2、测试设计阶段 根据测试计划与要求，对被测试单元设计测试用例，一般由测试人员和测试程序员共同完成。主要工作内容： （1）设计测试用例。 （2）获取测试用例的数据。 （3）确定测试的顺序。 （4）获取测试资源，建立测试环境。 （5）编写测试程序及测试说明文档。 3、测试执行阶段 根据设计阶段设计好的测试用例，由测试人员对指定的单元进行测试，记录测试步骤及测试结果。主要内容如下： （1）配置单元测试环境。 （2）执行设计阶段的测试用例，并记录执行过程。 （3）记录执行测试结果。 4、生成测试报告 根据执行阶段产生的测试结果，由测试分析人员进行分析、总结，得到测试结论并写出测试报告。主要完成两个方面工作： （1）根据测试设计中的期望值与实际测试执行结果比较，判定该测试能否通过，并记录结果。 （2）若测试不能通过，分析其不能通过的原因，填写软件问题报告，并提出相关建议。 单元测试的策略与方法 静态测试与动态测试相结合 ​ 单元测试是一种静态与动态相结合的测试。在执行动态测试之前，经过编译后的单元测试内容，先进行静态代码复审，找出其中的错误，可以由程序设计人员、程序编写人员和程序测试人员参与，由软件设计能力较强的高级程序员任组长，在研究软件设计文档基础上召开审查会议，分析程序逻辑与错误清单，测试预演，人工测试，代码复审后再进行计算机代码执行活动的动态测试。所以说是静态与动态相结合的测试。 白盒测试与黑盒测试相结合 ​ 单元测试主要采用白盒测试方法，辅以黑盒测试方法。其中白盒测试应用于代码评审、单元程序执行。在白盒测试方法中，以路径覆盖为最佳准则，且系统内多个模块可以并行进行测试。而黑盒测试方法则应用于模块、组件等大单元的功能测试。 人工测试与自动化测试相结合 ​ 人工测试是由测试人员手工逐步执行所有的活动，并观察每一步是否成功完成。人工测试是任何测试活动的一部分，在开发初始阶段软件及其用户接口还未足够稳定时尤其有效。 在不能使用自动化测试工具时，必须采用人工测试的方法对单元相关内容进行测试。 ​ 自动化测试 是把以人为驱动的测试行为转化为机器执行的一种过程。在设计了测试用例并通过评审之后，由测试人员采用自动化测试工具，根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，节省人力、时间或硬件资源，提高测试效率。 "},"page/1030.html":{"url":"page/1030.html","title":"集成测试","keywords":"","body":"集成测试 集成测试的概述 集成测试的定义 集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行集成测试。 集成测试是单元测试的逻辑扩展。在现实方案中，集成是指多个单元的聚合，许多单元组合成模块，而这些模块又聚合成程序的更大部分，如分系统或系统。集成测试采用的方法是测试软件单元的组合能否正常工作，以及与其他组的模块能否集成起来工作。最后，还要测试构成系统的所有模块组合能否正常工作。集成测试所持的主要标准是《软件概要设计规格说明》，任何不符合该说明的程序模块行为都应该加以记载并上报。 集成测试关注的主要内容 （1）模块接口的数据交换； （2）各子功能组合起来能否达到预期要求的父功能； （3）模块间是否有不利影响； （4）全局数据结构是否有问题； （5）单个模块的误差是否会累积放大。 集成测试的目标 集成测试的目标是按照设计要求使用那些通过单元测试的构件来构造程序结构。单个模块具有高质量但不足以保证整个系统的高质量。有许多隐蔽的失效是高质量模块间发生非预期交互而产生的。 判断集成测试是否完成，可从以下几个方面进行检查： （1）成功地执行了测试计划中规定的所有集成测试； （2）修正了所发现的错误； （3）测试结果通过了专门小组的评审。 集成测试应由专门的测试小组来进行，测试小组是由有经验的系统设计人员和程序员组成。整个测试活动要在评审人员出席的情况下进行。 测试小组应负责对测试结果进行整理、分析，形成测试报告。测试报告中要记录实际的测试结果、在测试中发现的问题、解决这些问题的方法以及解决之后再次测试的结果。此外还应提出不能解决、还需要管理人员和开发人员注意的一些问题，提供测试评审和最终决策，以便提出处理意见。 集成测试的方法 常用的集成测试方法有： 大爆炸集成（Big bang integration) 自顶向下集成（Top down integration） 自底向上集成（Bottom up integration) 三明治集成（Sandwich testing） 大爆炸集成测试 大爆炸集成测试概述 大爆炸集成也称为一次性组装或整体拼装，是一种非增量式组装方式。 这种集成测试策略的做法就是把所有通过单元测试的模块一次性集成到一起进行测试，不考虑组件之间的互相依赖性及可能存在的风险。 例子 大爆炸集成测试优点 （1）可以并行测试所有模块。 （2）需要的测试用例数目少。 （3）测试方法简单、易行。 大爆炸集成测试缺点 （1）一次运行成功的可能性不大。 （2）如果一次集成的模块数量多，集成测试后可能会出现大量的错误。很可能新增更多的新错误，新旧错误混杂，给程序的错误定位与修改带来很大的麻烦。 （3）即使集成测试通过，也会遗漏很多错误。 大爆炸集成测试适用范围 （1）只需要修改或增加少数几个模块的前期产品稳定的项目； （2）功能少，模块数量不多，程序逻辑简单，并且每个组件都已经过充分单元测试的小型项目； （3）基于严格的净室软件工程（由IBM公司开创的开发接近零缺陷的软件的成功做法）开发的产品，并且在每个开发阶段，产品质量和单元测试质量都是相当高质量的产品。 自顶向下集成测试 自顶向下集成测试概述 自顶向下的集成测试就是按照系统层次结构图，以主程序模块为中心，从顶层控制（主控模块）开始，自上而下按照深度优先或者广度优先策略，对各个模块一边组装一边进行测试。 采用同设计顺序一样的思路对被测系统进行测试，来验证系统的功能性和稳定性。 自顶向下集成测试步骤 （1）先对主控模块进行测试，用桩模块代替所有直接附属于主控模块的模块。 （2）根据选定的优先策略（广度或深度优先），每次用一个实际模块代替一个桩模块进行测试。 （3）结合下一模块的同时进行测试。 （4）为了保证加入的模块没有引入新的错误，需要进行回归测试。 （5）重复（2）-（4）过程，直到所有的模块集成测试完成。 例子 自顶向下集成测试优点 (1)较早验证了主要的控制和判断点； (2)功能可行性较早得到证实； (3)最多只需要一个驱动模块； (4)可以与设计并行进行测试； (5)支持故障隔离等。 自顶向下集成测试缺点 (1)桩开发和维护的成本大； (2)底层组件的一个需求的修改会导致许多顶层组件的修改； (3)底层模块越多，会导致底层测试不充分。 自顶向下集成测试适用范围 自顶向下集成测试主要适合于结构化编程方法的软件产品，且产品结构相对简单。 自底向上集成测试 自底向上集成测试概述 自底向上集成是从系统层次结构图的最底层模块开始按照层次结构图，逐层向上进行组装和集成测试的方式。 自底向上集成测试测试步骤 （1）从最底层的模块开始组装测试； （2）编写驱动程序，协调测试用例的输入与输出； （3）测试集成后的构件； （4）使用实际模块代替驱动程序，按程序结构向上组装测试后的构件； （5）重复（2）-（4）步骤，直到系统的最顶层模块被加入到系统中测试完成为止。 例子 自底向上集成测试优点 较早验证底层模块； 工作最初可以并行集成测试，集成策略小； 减少桩模块编写的工作量，支持故障隔离。 自底向上集成测试缺点 动模块开发工作量大； 对高层的验证在最后，设计上的错误不能被及时发现。 自底向上集成测试适用范围 自底向上集成测试适应于大部分采用结构化编程方法的软件产品，且产品结构相对简单。 三明治集成测试 三明治集成测试概述 三明治集成是一种混合增殖式测试策略，综合了自顶向下和自底向上两种集成方法，把系统划分成三层，中间一层为目标层，目标层上采用自顶向下集成，目标层下采用自底向上集成。 例5-5 对于图5-3中的模块，我们采用三明治集成测试。 对分别已进行了单元测试的各个模块，在下层分别集成模块B、E、F和D、G进行测试，在上层集成模块A、B、C、D进行测试，最后将所有模块集成测试。 三明治集成测试优点 集合了自顶向下和自底向下上两种集成测试的优点。 三明治集成测试缺点 由于中间层是最后集成测试，因此中间层在被集成前测试不充分。 三明治集成测试适用范围 对大部分开发软件项目都可以使用。 其他集成测试策略 核心系统测试 核心系统先行集成测试法的思想是先对核心软件部件进行集成测试，在测试通过的基础上再按各外围软件部件的重要程度逐个集成到核心系统中。每次加入一个外围软件部件都产生一个产品基线，直至最后形成稳定的软件产品。核心系统先行集成测试法对应的集成过程是一个逐渐趋于闭合的螺旋形曲线，代表产品逐步定型的过程。 优点 该集成测试方法对于快速软件开发很有效果，适合较复杂系统的集成测试，能保证一些重要的功能和服务的实现。 缺点 采用此法的系统一般应能明确区分核心软件部件和外围软件部件，核心软件部件应具有较高的耦合度，外围软件部件内部也应具有较高的耦合度，但各外围软件部件之间应具有较低的耦合度。 高频集成测试 高频集成测试是指同步于软件开发过程，每隔一段时间对开发团队的现有代码进行一次集成测试。 如某些自动化集成测试工具能实现每日深夜对开发团队的现有代码进行一次集成测试，然后将测试结果发到各开发人员的电子邮箱中。该集成测试方法频繁地将新代码加入到一个已经稳定的基线中，以免集成故障难以发现，同时控制可能出现的基线偏差。 优点 该测试方案能在开发过程中及时发现代码错误，能直观地看到开发团队的有效工程进度。 缺点 在于测试包有时候可能不能暴露深层次的编码错误和图形界面错误。 基于功能的集成测试 基于功能的集成测是从功能角度出发，按照功能的关键程度对模块的集成顺序进行组织，尽可能早点进行测试。其关注于测试验证系统的关键功能。 此方法适应于对较大风险的产品、技术探索的项目或者是对功能实现没有把握的产品，其功能的实现比质量要关键。 基于进度的集成测试 基于进度的集成测试主要是从系统的进度和质量两方面的考虑，尽早地进行集成测试，以提高开发和集成的并行性，有效地缩短项目的开发时间，提高开发项目的质量。 但此方法早期测试缺乏整体性，仅能进行独立的集成，导致许多接口要到后期才能验证。桩模块与驱动模块的开发量大，模块可能不稳定产生变化，导致测试的重复与浪费。 基于风险的集成测试 基于风险的集成测试是基于一种假设的方法，系统的错误往往集中在系统风险最高的模块中，因此对高风险的模块接口先进行重点测试，从而保证系统的稳定性。 尽早验证高风险的接口有助于加速系统的稳定性，有利加强对系统的信心。此方法可以与功能集成测试结合起来使用。主要适应于系统中风险较大的模块测试。 客户/服务器的集成测试 客户/服务器的集成测试主要针对客户/服务器系统，对系统客户端与服务器端交互进行集成测试。 先单独测试每个客户端和服务器端，再将第一个客户端与服务端集成测试，加入下一个客户端与服务端集成测试，如此下去，将所有客户端与服务器端集成测完成。 此方法对集成次序没有约束，有利于复用和扩充；支持可控制和可重复的测试。但驱动模块与桩模块的开发成本高。 集成测试阶段的测试过程 根据IEEE标准，集成测试过程划分为5个阶段： 计划阶段 设计阶段 实施阶段 执行阶段 评估阶段 集成测试计划阶段 集成测试准备 在进行集成测试前，先要准备如下内容： （1）测试的文档准备：需求规格说明书、概要设计文档、产品开发计划。 （2）人员组织：测试人员、开发人员、测试质量控制员、测试经理、开发经理、产品经理。 各相关人员职责见表5-1所示。 集成测试策略和环境 集成测试采用的测试技术和工具，完成测试影响的资源分配及特殊的考虑。 其环境考虑内容如下： （1）硬件环境： 尽可能考虑实际环境。 （2）操作系统环境：不同机型使用不同的操作系统版本。 （3）数据库环境：从性能、版本、容量等多方面考虑。 （4）网络环境 测试日程计划 根据软件设计文档来评估测试有多少项目，再根据测试的工作量进行安排。 开始时间在概要设计完成评审后大约一个星期。 活动步骤 （1）确定被测试对象和测试范围； （2）评估集成测试被测试对象的数量及难度，即工作量 ； （3）确定角色分工和任务； （4）标识出测试各阶段的时间、任务、约束等条件； （5）考虑一定的风险分析及应急计划； （6）考虑和准备集成测试需要的测试工具，测试仪器，环境等资源； （7）考虑外部技术支援的力度和深度，以及相关培训安排； （8）定义测试完成标准。 输出 集成测试计划阶段最后得到集成测试计划，此计划必须通过概要设计阶段基线评审通过。 集成测试设计阶段 时间安排 集成测试的设计在系统详细设计阶段就可以开始。 依据 集成测试的设计阶段的主要依据是：需求规格说明书、概要设计、集成测试计划。 入口条件 系统的概要设计基线已通过评审。 活动步骤 （1）被测对象结构分析； （2）集成测试模块分析； （3）集成测试接口分析； （4）集成测试策略分析； （5）集成测试工具分析； （6）集成测试环境分析。 输出 集成测试设计阶段的输出是集成测试设计方案。 出口条件 集成测试设计通过详细设计基线评审。 集成测试实施阶段 根据集成测试计划，建立集成测试环境，完成测试设计任务。 时间安排 在系统编码阶段开始后就可以进行了。 依据 系统的需求规格说明书、概要设计、集成测试计划、集成测试设计计划。 入口条件 系统的详细设计基线通过评审。 活动步骤 （1）集成测试用例设计； （2）集成测试代码设计（如果需要）； （3）集成测试脚本设计（如果需要）； （4）集成测试工具准备（如果需要）； 输出 最后输出有：集成测试用例、集成测试规程、集成测试代码、集成测试脚本、集成测试工具。 测试用例模板如表5-2所示。 出口条件 集成测试设计阶段的出口条件是：测试用例和测试规程通过编码阶段基线评审。 集成测试执行阶段 按照集成测试用例设计要求进行构建平台。 时间安排 系统的单元测试已经完成后就可以开始执行系统的集成测试了。 输入 集成测试需要的基本内容：需求规格说明书、概要设计、集成测试计划、集成测试例、集成测试规程、集成测试代码（如果有）、集成测试脚本、集成测试工具、详细设计代码、单元测试报告。 入口条件 系统的单元测试阶段已经通过基线化评审。 活动步骤 （1）执行集成测试用例； （2）回归集成测试用例； （3）撰写集成测试报告； 输出 集成测试实施后，最后生成集成测试报告。 出口条件 集成测试报告通过集成测试阶段基线评审。 集成测试评估阶段 由测试设计员负责，与集成测试人员、编码员、设计员等对集成测试结果进行统计，生成测试执行报告和缺陷记录报告。 并对集成测试进行评估，测试结果进行评测，形成结论，最后整理形成报告。 "},"page/1031.html":{"url":"page/1031.html","title":"系统测试","keywords":"","body":"系统测试 系统测试的概述 系统测试定义 系统测试是将集成好的软件系统，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支持软件、数据等其它系统元素结合在一起，在实际运行（使用）环境下所进行的一系列测试活动。 系统测试的目的 通过与系统的需求定义比较，检查软件是否存在与系统定义不符合或与之矛盾的地方，以验证软件系统的功能和性能等满足其规约所指定的要求。 系统测试技术要求 （1） 系统的每个特性应至少被一个正常测试用例和一个被认可的异常测试用例所覆盖。 （2）测试用例的输入应至少包括有效等价类值、无效等价类值和边界数据值。 （3）应逐项测试系统/子系统设计说明规定的系统的功能、性能等特性。 （4）应测试软件配置项之间及软件配置项与硬件之间的接口。 （5）应测试系统的输出及其格式。 （6）应测试运行条件在边界状态和异常状态下，或在认为设定的状态下，系统的功能和性能。 （7）应测试系统访问和数据安全性。 （8）应测试系统的全部存储量、输入/输出通道和处理时间的余量。 （9）应按系统或子系统设计文档的要求，对系统的功能、性能进行强度测试 （10）应测试设计中用于提高系统安全性、可靠性的结构、算法、容错、冗余、中断处理等方案。 （11）对完整性级别高的系统，应对其进行安全性、可靠性分析，明确每一个危险状态和导致危险的可能原因，并对此进行针对性的测试。 （12）对有恢复或重置功能需求的系统，应测试其恢复或重置功能和平均恢复时间，并且对每一类导致恢复或重置的情况进行测试。 （13）对不同的实际问题应外加相应的专门测试。 系统测试的内容 国标GB/T 16620针对系统测试的测试内容：适应性、准确性、互操作性、安全保密性、成熟性、容错性、易恢复性、易理解性、易学性、易操作性、吸引性、时间特性、资源利用性、易分析性、易改变性、稳定性、易测试性、适应性、易安装性、共存性、替换性和依从性等方面（有选择的）。 功能性 主要测试内容如下： （1）适应性方面 （2）准确性方面 （3）互操作性方面 （4）安全保密性方面 可靠性 主要测试的内容如下： （1）成熟性方面 （2）容错性方面 （3）易恢复性方面 易用性 主要测试的内容如下： （1）易理解方面: （2）易学性方面 （3）易操作性方面 （4）从吸引性方面 效率 主要测试的内容如下： （1）时间特性方面: （2）资源利用性方面 维护性 主要测试的内容如下： （1）易分析性方面：可设计各种情况的测试用例运行系统，并监测系统运行状态数据，检查这些数据是否容易获得、内容是否充分。若软件具有诊断功能，则应测试该功能。 （2）易改变性方面：可测试能否通过参数来改变系统。 （3）易测试性方面：可测试软件内置的测试功能，确认它们是否完整和有效。 可移植性 主要测试的内容如下： （1）适应性方面 （2）易安装性方面 （3）共存性方面 （4）易替换性方面 （5）依从性方面 系统测试的方法与过程 系统测试方法 功能测试 对产品的功能进行测试，检验是否实现、是否正确实现系统功能。 性能测试 对产品的性能进行测试，检验是否达标、是否能够保持性能。 负载测试 在人为设置的高负载（大数据量、大访问量）的情况下，检查系统是否发生功能或者性能上的问题。 压力测试 在人为设置的系统资源紧缺情况下，检查系统是否发生功能或者性能上的问题。 疲劳测试 在一段时间内（经验上一般是连续72小时）保持系统功能的频繁使用，检查系统是否发生功能或者性能上的问题。 易用性测试 检查系统界面和功能是否容易学习、使用方式是否规范一致，是否会误导用户或者使用模糊的信息。 安装测试 检查系统安装是否能够安装所有需要的文件/数据并进行必要的系统设置，检查系统安装是否会破坏其他文件或配置，检查系统安装是否可以中止并恢复现场，检查系统是否能够正确卸载并恢复现场，检查安装和卸载过程的用户提示和功能是否出现错误。有时候将安装测试作为功能测试的一部分。 配置测试 在不同的硬件配置下，在不同的操作系统和应用软件环境中，检查系统是否发生功能或者性能上的问题。 文档测试 检查系统的文档是否齐全，检查是否有多余文档或者死文档，检查文档内容是否正确/规范/一致等。 安全测试（包括病毒、加密、权限） 检查系统是否有病毒，检查系统是否正确加密，检查系统在非授权的内部或外部用户访问或故意破坏时是否出现错误。 恢复测试 在人为发生系统灾难（系统崩溃、硬件损坏、病毒入侵等）的情况下，检查系统是否能恢复被破坏的环境和数据。 回归测试 是一种选择性重新测试，目的是检测系统或系统组成部分在修改期间产生的缺陷，用于验证已进行的修改并未引起不希望的有害效果，或确认修改后的系统或系统组成部分仍满足规定的要求。 健全测试 检查系统的功能和性能是否基本可以正常使用，来确定是否可以继续进行系统测试的其他内容。 交付测试 关闭所有缺陷报告，确保系统达到预期的交付标准。 演练测试 在交付给用户之前，利用相似的用户环境进行测试。例如：奥运会MIS系统在2008年前用于其他比赛。 背靠背测试 设置一组以上的测试团队，在互相不进行沟通的情况下独立进行相同的测试项目，用来评估测试团队的效果并发现更多的错误。开始用于测试外包，现在也用于内部测试。 度量测试 在系统中人为地放入错误（播种），并根据被发现的比例来确定系统中遗留的错误数量。 开始用于测试外包，现在也用于内部测试。 比较测试 与竞争产品及本产品的旧版本测试同样的内容，来确定系统的优势和劣势。严格地说，比较测试属于系统测评的内容，BenchMarking是一种特殊的比较测试。 系统测试过程 制定系统测试计划 系统测试计划是软件测试员与产品开发小组交流的主要方式。测试小组共同协商测试计划，测试组长按照测试模板起草《系统测试计划》。 其主要内容有： 规定测试活动的范围、测试方法、资源（测试环境、测试辅助工具）与进度；明确正在测试的项目，要测试的特性、要执行的测试任务、每个任务的负责人、以及与计划相关的内容。 设计系统测试用例 系统测试小组成员依据《系统测试计划》和指定的模板，设计《系统测试用例》。其中包括三个部分:测试设计说明、测试用例说明、测试程序和测试过程说明。 测试设计说明 其主要内容如下： 标识符、要测试的特性、方法、测试用例确认、通过/失败规则 测试用例说明 IEEE829提出测试用例说明是“编写用于输入的实际数值和预期输出结果数值，测试用例还明确指出使用具体测试用例产生的测试程序的任何限制。” 其主要的内容如下： 标识符、测试项、输入说明、输出说明、环境要求、特殊过程要求、用例之间的依赖性。 测试程序和过程说明 IEEE829定义测试程序是“明确指出为实现相关测试设计而操作软件系统和试验具体测试用例的全部步骤。” 测试程序或测试脚本说明详细定义了执行测试用例的每一步操作。 主要内容如下： 标识符、目的、特殊要求、程序步骤 执行系统测试 系统测试人员依据《系统测试计划》和《系统测试用例》对系统进行测试，并将执行结果记录在《系统测试报告》中，并及时将存在的缺陷通报给开发人员。 开发人员及时改正已发现的缺陷，并由测试人员进行回归测试，以确保不会引入新的缺陷。 软件缺陷报告包括的主要内容如下： 标识符、总结、事件描述、影响 提交系统测试报告 系统所有的测试执行完成后，提交测试报告文档。 测试报告模板主要内容如下： - 1 引言 - 1.1编写的目的 - 1.2编写的背景 - 1.3术语解释 - 1.4参考资料 - 2测试概要 - 2.1系统简介 - 2.2测试计划描述 - 2.3测试环境 - 3测试结果及分析 - 3.1测试执行情况 - 3.2测试功能报告 - 3.2.1系统管理模块测试报告单 - 3.2.2功能插件模块测试报告单 - 3.2.3网站管理模块测试报告单 - 3.2.4内容管理模块测试报告单 - 3.2.5辅助工具模块测试报告单 - 3.3系统性能测试报告 - 3.4不间断运行测试报告 - 3.5易用性测试报告 - 3.6安全性测试报告 - 3.7可靠性测试报告 - 3.8可维护性测试报告 - 4测试结论与建议 - 4.1测试人员对需求的理解 - 4.2测试准备和测试执行过程 - 4.3测试结果分析 - 4.4建议 "},"page/1032.html":{"url":"page/1032.html","title":"确认测试","keywords":"","body":"确认测试 "},"page/1033.html":{"url":"page/1033.html","title":"验收测试","keywords":"","body":"验收测试 "},"page/1025.html":{"url":"page/1025.html","title":"是否人工干预","keywords":"","body":"是否人工干预 "},"page/1026.html":{"url":"page/1026.html","title":"人工测试","keywords":"","body":"人工测试 "},"page/1027.html":{"url":"page/1027.html","title":"自动化测试","keywords":"","body":"自动化测试 软件测试自动化的基本概念 测试自动化的定义 软件测试自动化是通过软件测试工具，按照测试人员预定的计划和测试用例对软件产品进行自动测试。软件测试自动化是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。 测试自动化的意义 （1）测试自动化可以节约时间。（2）测试自动化会更可靠，提高了精确度和准确度。（3）测试自动化有助于立即测试。（4）测试自动化可以减轻测试工程师的测试工作量，使他们能把注意力放在更有创造性的任务上。（5）测试自动化可以更好地利用全球资源。（6）有些测试必须进行自动化测试。 自动化测试术语 （1）测试用例有两类测试用例：一类是自动化的测试用例，另一类是手工的测试用例。 （2）测试包测试包：是一组测试用例被组合并与一组场景关联。 （3）测试自动化框架：自动化测试框架是应用于自动化测试所用的框架，由一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。如图7-1所示。 自动化测试所需技能 可分为三种类型： （1）记录与回放：测试工作人员只需录制键盘字符或鼠标点击的行动序列，并在以后按照录制的顺序回放所记录的脚本就可重显操作过程的测试。 （2）数据驱动：这种方法关注不同的输入和输出条件。有助于开发生成输入条件集和对应预期输出的测试脚本。 （3）行动驱动：应用程序中出现的所有行动都会以为自动化定义的一般控件集为基础，自动测试。用户只需要描述操作，其他所需的一切都会自动生成和使用。 对于这三种类型，各类需要的技能有所区别 类型 测试用例、框架自动化技能 记录与回放 脚本语言、记录—回放工具的使用 数据驱动 脚本语言、程序设计语言、数据生成技术知识、被测产品的使用 行动驱动 脚本语言、程序设计语言、被测试产品的设计和体系结构、框架的使用、创建框架的设计和体系结构技能、多个产品的通用测试需求 自动化测试的设计和体系结构 1、外部模块 ​ 两个外部模块：测试用例数据库和缺陷库。 测试用例数据库用来存放所有的测试用例、执行测试用例的步骤以及执行历史。 缺陷库包含特定公司在各种被测产品中发现的所有缺陷的详细信息。 2、场景与配置文件模块 ​ 配置文件包含一组在自动化中使用的变量。这些变量可以是针对测试框架的，也可以是针对测试自动化中的其他模块的；它们的取值可以动态改变的，以实现不同的执行、输入、输出和状态条件。 3、测试用例与测试框架模块 ​ 测试框架是将“要执行什么”和“如何执行”结合在一起的模块。测试框架从测试用例数据库中提取要自动化测试的特定测试用例，提取场景、提取变量及相关取值并执行测试用例。 4、工具与结果模块 ​ 当测试框架执行其操作时，可能需要一组相关工具。如：IP分组模拟器、用户登录模拟器、计算机模拟器等。 结果模块用来存放测试框架执行测试用例的每个执行结果、对应的场景和变量值等，以供进一步分析和处理。注意，测试框架运行测试用例得到的结果不能覆盖以前运行测试用例的结果。 5、报告生成器与报告/指标模块 ​ 报告生成器是提取必要的输入并准备格式化报告的模块。一旦得到测试结果，报告生成器就可以生成相关的指标。所生成的所有报告和指标都存储在自动化的报告/指标模块中，以备日后使用和分析。 自动化测试的过程模型 自动化测试的过程模型有三个阶段： 自动化测试需求分析 自动化测试框架的搭建 自动化测试包的测试阶段 1、 自动化测试需求分析 ​ 当测试项目满足了自动化测试的前提条件，并确定在该项目中需要使用自动化测试时，我们便开始进行自动化测试需求分析。此过程需要确定自动化测试的范围以及相应的测试用例、测试数据，并形成详细的文档，以便于自动化测试框架的建立。 2、自动化测试框架的搭建 自动化测试框架要素如下： （1） 公用的对象：不同的测试用例会有一些相同的对象被重复使用，如窗口、按钮、页面等 （2） 公用的环境：各测试用例也会用到相同的测试环境，将该测试环境独立封装，在各个测试用例中灵活调用，也能增强脚本的可维护性。 （3） 公用的方法：当测试工具没有需要的方法时，而该方法又会被经常使用，我们便需要自己编写该方法，以方便脚本的调用。 （4） 测试数据：当一个测试用例需要执行很多个测试数据时，可将这些测试数据放在一个独立的文件中，由测试脚本执行到该用例时读取数据文件，从而达到数据覆盖的目的。 3、产品和自动化测试包的测试阶段 ​ 产品和自动化测试开发的每个阶段可以执行一组活动，包括：产品在需求阶段采集开发需求时，同时完成针对测试产品的测试需求，针对自动化开发的需求和针对自动化测试的需求。类似地，在策划和设计阶段也可以执行一组活动，包括：针对产品和自动化测试的编码构成W字模型的编码阶段，这个阶段要交付产品和测试包。W字模型如图所示。 自动化测试的方案与选择 自动化测试的前提条件 实施自动化测试之前需要对软件开发过程进行分析，以观察其是否适合使用自动化测试。通常需要同时满足以下条件： 1、 需求变动不频繁 2、 项目周期足够长 3、 自动化测试脚本可重复使用 自动化测试适合的场合 适合于软件测试自动化的场合如下： 1、回归测试 2、文档的管理 3、测试报告生成 4、确定覆盖率 自动化测试选择原则 1、自动化测试选择相关因素 （1）项目的影响：自动化测试能否对项目进度、覆盖率、风险有积极的作用。 （2）复杂度：自动化测试能否容易实现。 （3）时间：自动化测试需要多长的时间，项目开发要有足够的测试时间。、 （4）稳定性：代码和需求的相对稳定性，代码是否长期保持相对稳定，功能特性变化速度是否快等。 （5）资源：是否有足够的人力资源、物力资源来测试运行。 （6）覆盖率：自动化测试能否覆盖程序的关键特性和功能。 （7）自动执行：负责执行的测试人员是否有足够的技能与时间运行测试。 2、自动化测试选择的建议 （1）选择尽可能少的自动化产品覆盖尽可能多的平台，以降低产品投资和团队的学习成本。 （2）测试流程管理自动化通常应该优先考虑，以满足为企业测试团队提供流程管理支持的需求。 （3）在投资有限的情况下，性能测试自动化产品将优先于功能测试自动化被考虑。 （4）在考虑产品性价比的同时，应充分关注产品的支持服务和售后服务的完善性。 （5）尽量选择趋于主流的产品，以便通过行业间交流甚至网络等方式获得更为广泛的经验和支持。 （6）应对测试自动化方案的可扩展性提出要求，以满足企业不断发展的技术和业务需求。 自动化测试的工具与选择 自动化测试工具分类 1、白盒测试工具 白盒测试工具多为一个套件，其中包括了动态错误检测、时间性能分析和覆盖率统计等多个工具。 常见的静态测试工具有：Telelogic公司的Logiscope、PR公司的PRQA；动态测试工具有：Compuware公司的DevPartner、IBM Rational公司的PurifyPlus 等。 2、黑盒测试工具 ​ 一般利用脚本的录制和回放模拟用户操作，将被测试系统的输出结果记录下来，同预先给定的输出值进行比较，分析得出测试结果。并可以在测试脚本加以修改。多用于确认阶段及其对应的回归测试中，其测试对象多为拥有图形用户界面的应用程序。 ​ 常见的黑盒测试工具有：IBM Rational公司的Team Test Tobot和Compuware公司的QACenter、HP-Mercury公司的WinRunner和QTP（QuickTest Professional）等。 3、网络测试工具 ​ 网络测试工具主要包括网络故障的定位、网络性监测工具、网络模拟仿真工具等，分析分布式应用性能，关注应用、网络与其他元素内部的交互式活动，以便使网络管理员了解网络不同位置和不同活动之间应用的行为。 常见的网络测试工具有：Network Associate提供的Network Sniffer、HP-Mercury公司的LoadRunner等。 4、专用代码测试工具 ​ 专门支持某类语言的测试工具。 ​ 常见的有:BoundsCheck用于VC++代码的自动侦错和调试工具，CodeReview是VB代码分析工具，Jcheck是用来分析Java语言的执行过程并进行图形化的工具。还有Java环境下的单元测试工具Junit和C++环境下的单元测试工具CppUnit等。 5、错误捕获工具 ​ 错误捕获工具是用来捕获软件错误后进行程序调试的工具。可以由开发人员自行编写，还可以使用集成开发环境中自带的这种工具功能，也可以购买专业的调试软件。 ​ 常见的有：Compuware NuMega推出的一系列软件等。 6、测试管理工具 ​ 测试管理工具是对测试需求、测试计划、测试用例、测试实施、测试报告等活动和相应制品进行管理的一类工具。 ​ 常见的管理工具有：Mercury Interactive公司的TestDirector、IBM公司TestManager和Compuware公司的TrackRecord、HP-Mercury公司的Quality Center等。 自动化测试工具的选择 1、选择测试工具的准则 （1）满足需求（2）技术预期（3）培训与技能（4）管理问题 2、工具选择与部署步骤 （1）在所讨论过的一般需求中提取测试包需求，补充其他需求。（2）保证已经考虑过前面所讨论的经验。（3）收集其他公司使用类似工具的经验。（4）准备向提供商提出的有关成本、工作量和支持问题的检查单。（5）列出满足以上需求的工具（优先列出提供源代码的工具）。（6）评价并最后确定一个或一组工具，并对所有测试开发人员提供工具培训。（7）培训工具的所有潜在用户后，为各个测试团队部署该工具。 3、注意事项 （1）各方面因素综合考虑（2）自动化测试不能完全替代手工测试（3）分析投入回报问题 "},"page/1078.html":{"url":"page/1078.html","title":"面向对象测试","keywords":"","body":"面向对象测试 面向对象测试的基本概念 面向对象技术的特点及其对软件测试的影响 面向对象程序通常由一系列类组成，在类定义中封装了数据及作用在数据上的操作，数据和操作统称为特征。对象是类的实例。类和类之间按继承关系组成一个无环有向图结构，父类中定义了共享的公共特征，子类除继承父类中定义的所有特征外，还可以引入新的特征，也允许对继承的方法重新定义。面向对象语言提供的动态绑定机制将对象与方法动态地联系起来。面向对象程序的封装性、继承性、动态绑定等特性使程序具有较大的灵活性，给软件测试提出了新的要求，这使得面向对象软件的测试更加复杂。 1、 类和对象对测试的影响 在面向对象系统中，系统的最小可测试单元不再是函数或过程，而是类和对象。类和对象封装了很多方法和属性，在很大程度上增加了系统聚合度，降低耦合度，提高了系统整体的可维护性；但却牺牲了单元测试容易性，增加了复杂性。 基于状态单元测试方法，其基本思想是：将类和对象看作一台有限状态自动机，其状态由其属性来表征，其方法根据当前状态或外部发送过来的消息，作出相应的状态转换和输出信息。然后在此基础上，为有限状态自动机的每个状态设计相应的测试用例，对每个状态进行分而治之地测试，降低测试的复杂度。在面向对象设计时，往往将类和对象动态特性描述成有限状态自动机。因而，我们可以很容易地实现基于状态单元测试方法，即利用前期设计的有限状态自动机，为每个状态设计相应的测试用例。 例6-1用数组栈类的例子来说明。在数组栈类中主要含有方法Push、PoP和属性Top，其中属性Top用于指出栈顶元素在数组中的位置。数组栈的有限状态机如图6-1所示，此自动机包括正常、空和满三个状态，状态由属性Top来表征，例如ToP＝0表示空状态。在设计测试用例时，必须保证这些用例能够使得该类所有状态都得到遍历；同时在每个状态中还需要设计测试用例，激发非法操作(例如，在空状态，调用Pop操作)以及验证该类的健壮性。 数组栈的有限状态机 2、继承对测试的影响 ​ 面向对象的继承是允许在已有类（基类或父类）的基础上定义新类，新类称为派生类或子类。而派生出的子类可以继承父类的特性，同时还可以增加自己的功能和修改继承得到的功能。在继承关系中，子类不仅包含父类的所有成员，更重要是它复制了父类的接口。 ​ 面向对象程序设计语言提供这种机制给了程序员一定的灵活性，但给软件测试带来一定的影响，即父类中的方法在子类环境下是否需要重新测试？ 例子 3、 封装和信息隐蔽对测试的影响 ​ 封装是将一组相关的概念聚集在一个单元内。面向对象的封装是将操作和属性包装在一个对象类型中，只能通过封装体提供的接口来访问和修改。 ​ 通常的解决的方法是在类和对象上添加一个成员函数，该函数用于读取(而不是修改)对象的状态信息。当测试时，用来考察对象的状态变化。但必须保证该函数在一定程度上的正确性。为了达到更好的测试效率，甚至可以添加能够捕获外部或内部发送过来的消息的成员函数，记录各消息的参数发送的时间。当测试完成后，可将这些成员函数删除，以便提高软件系统的运行速度。 增加一个成员函数，（不影响其正确性）--> 测试--> 去除成员函数 4、多态性对测试的影响 ​ 多态性是面向对象方法的关键特性之一。可以根据发生消息的对象不同采取不同的处理方法，它使得系统在运行时能自动为给定的消息选择合适的实现代码。这给程序员提供了高度柔性、问题抽象性和易于维护性。但多态性所带来的不确定性，也使得传统测试实践中的静态分析法遇到了不可逾越的障碍。与此同时，还增加了系统运行中可能的执行路径，加大了测试用例的选取难度和数量，这种不确定性和骤然增加的路径组合给测试覆盖率的满足带来了挑战。多态性给软件测试带来的问题仍然是目前研究的重点及难点问题之一。 动态的无法用静态来搞，情况太多，目前未解决的问题 5、 进一步讨论 ​ 在单元测试中，我们引入的基于状态单元测试方法有其致命的弱点，就是测试效率低。仍旧以数组栈为例，假设该数组栈栈空间为64KB，每一个数据项占一个字节，则将数组栈从空状态切换到满状态，必须调用PUSH()方法64×1024次。由于对象的信息隐蔽和封装性，无法直接修改对象属性。也就是说，若要测试在数组栈满状态下对象的特性，首先必须调用PUSH（)方法64×l024次，以便切换到满状态下，这样大大降低了测试的效率。同样，对于类中重新定义过的方法和某些继承下来的方法重新测试时，也存在状态切换低效率问题。 切换状态无法直接修改，因为封装性，只能一个个规规矩矩的加入 添加友元类来添加修改要切换状态的类 例6-3 我们定义一个测试类，该类在程序调试时刻，默认为其他类的友员类，可以读取和修改其他类的属性。在测试代码中，根据测试需要，可以插入修改和读取被测试类的属性。下面是测试类的接口定义： typedef tagProperty_List //属性列表 { String Property_Name[]; //属性名称 String Property_Type[]; //属性类型 Void* Property——Ref[]; //属性引用地址 } Property_List; 面向对象测试模型 ​ 面向对象的开发模型，分为面向对象分析（OOA）、面向对象设计（OOD）、和面向对象编程（OOP）三个阶段。 ​ 将面向对象的软件测试分为：面向对象分析的测试（OOATest），面向对象设计的测试（OODTest），面向对象编程的测试（OOPTest） 面向对象测试模型 OOA Test:面向对象的分析测试OOD Test:面向对象设计的测试OOP Test:面向对象编程的测试OO Unit Test:面向对象单元测试OO Intergrate Test:面向对象集成测试OO System Test:面向对象系统测试 面向对象的测试方法概述 面向对象的测试方法 ​ 将面向对象的测试分为三个层次：类的单元测试、类的集成测试和系统测试。 面向对象软件的测试分层如表6-1所示。 面向对象软件的测试层 传统测试 面向对象测试 单元测试 类测试(方法测试 对象测试) 集成测试 类的集成模块测试 系统测试 系统测试 在设计测试用例选择输入数据时，可以基于以下两个假设： (1)如果函数(程序)对某一类输入中的一个数据正确执行，对同类中的其他输入也能正确执行。 (2)如果函数(程序)对某一复杂度的输入正确执行，对更高复杂度的输入也能正确执行。例如需要选择字符串作为输入时，基于本假设，就无须计较字符串的长度，除非字符串的长度是要求固定的，如IP地址字符串。 面向对象的测试相关概念 1、测试特征 典型的测试特征有：（1） 控制依赖和数据依赖；（2） 状态转换、事务、规程、交互等；（3） 约束和断言，如因果关系、互斥关系、前后条件、不变式等；（4） 等价类、边界等。 2、测试用例 ​ 测试用例是被测对象对制定输入产生预期结果的表示。 4、测试层次结构 ​ 层次测试级与测试复杂性分解的思想，是软件测试的基本模式。面向对象软件测试根据测试层次结构可以分为单元级、集成级到系统级的分层测试，测试集成的过程是一个基于可靠部件组装系统的过程。 5、测试步骤 对于面向对象的测试，测试人员一般要做以下步骤：（1）为类创建一个实例，即对象，为构造函数传递合适的参数； （2）通过参数传递调用对象的方法并获取结果； （3）检查对象的内部数据。 面向对象的单元测试（类测试） （1）基于服务的测试：测试类中的每一个服务（即方法）； 测试类的方法 （2）基于对象的测试：因为类是一个抽象定义的、属性和操作的封装体，只有实例化后才能起作用，因此需要对类进行实例化测试，类实例化测试的实现是通过构造函数和析构函数来完成的； 类创建对象测试 （3）基于状态的测试：考察类的实例在某生命周期各个状态下的情况； 如数组栈的各个满不满状态 （4）基于响应状态测试：从类和对象的责任出发，以外界向对象发送特定的消息序列来测试对象。 发送消息看反应是否正确 在这里我们主要介绍基于服务的测试和基于状态的测试。 基于服务的测试 基于服务的类测试主要考察封装在类中的一个方法对数据进行的操作。Kung等人提出的块分支图（Block Branch Diagram，BBD）是一种比较好的类的服务测试模型。 、 基于服务的块分支图 服务f的BBD是一个五元组，可写为f=(Du，Dd，P，Fe，G) 其中：Du={di| di∈f 引用的全局数据或类数据}； Dd={di| di∈f修改了全局数据或类数据}； P={X1θ1，X2θ2，…，Xnθn，Xn+1θn+1∈f的参数表和函数返回值，θi为↓（表示输入）、↑（表示输出）、↓↑（表示输入/输出），若Xn+1缺省，则无返回值}； Fe={Fi| Fi∈被f 调用的其他服务}； G是一个有向图，叫块体，它是按照控制流图的思想修改f的程序流程图而来的，表示f的控制结构，f中的复合条件判断被分解，每个判断框只有单个的条件。 BBD的获得方法有两种： （1）采用逆向工程的方法，由源程序画出流程图构造出BBD图。 （2）是在软件的分析设计阶段构造出相应的BBD图。前一种方法可能因为源程序不正确而构造出错误的BBD图。后一种方法更可靠些。 例6-4 我们用C++设计一个矩形类Rectangle。要求如下：（1）该类中的私有变量存放Rectangle的长和宽，并且设置它们的默认值为1；（2）通过构造函数设置其长和宽，并确保长和宽值的范围为（0，50）；（3）并分别设置成员函数求周长Perimeter（）和求面积Aear（）。 其C++程序段如下： Class Rectangle { Private: float width; float height; Public: Rectangle(float w=1,float h=1){ if (w>0 && w0 && h 对类Rectangly中构造函数Rectangle()的BBD图 类Rectangle中构造函数Rectangle（）的BBD图 通过构造BBD图，采用基本路径测试的结构测试方法对类Rectangle中的构造函数Rectangle（）进行测式，查找语句覆盖和分支覆盖的错误。 具体步骤如下： （1）绘制BBD图对应的控制流图。先将判断条件改为单个条件，如图6-5（a）所示，再变换为对应的流图，如图6-5（b）所示。 （2）确定基本路径集。根据前面介绍的算法得复杂度为：判断框数+1=4+1=5。 Path1:①-②-③-④-⑥-⑦-⑧-⑩ Path2:①-②-⑤-⑥-⑦-⑧-⑩ Path3:①-②-③-⑤-⑥-⑦-⑧-⑩ Path4: ①-②-③-④-⑥-⑨-⑩ Path5: ①-②-③-④-⑥-⑦-⑨-⑩ 类Rectangle构造函数Rectangle（）的控制图和流图 （3）设计测试用例。 类Rectangle构造函数Rectangle（）的测试用例 ID 输入数据 输入数据 返回值 返回值 通过的路径 w h width heigth Test1 10 20 10 20 Path1 Test2 0 20 1 20 Path2 Test3 60 20 1 20 Path3 Test4 10 0 10 1 Path4 Test5 10 60 10 1 Path5 基于状态的测试 对象状态的测试是依赖对象状态的行为还不是控制结构或单个数据。所以状态测试的主要思想是考察类的实例在生命周期各个状态下的情况，以及外界向对象发送特定消息序列的方法来测试对象的响应状态。 通过构造OSD（Object State Diagram）模型来进行类的状态测试。 OSD模型是用于测试对象的动态行为的测试模型。对象状态图可以分为两种： （1）原子对象状态图（AOSD）：表现的是一个类的数据成员的状态和状态的转换，它可用作类的数据成员的动态行为的测试模型。 （2）复合对象状态图（COSD）：表现的是对象的正交的不同部分之间的动态行为，它可以用来检验对象的状态和状态的转换。 1、AOSD模型 AOSD中的转换是类的成员从源状态到目的状态的状态的改变。 AOSD=（S,σ，δ，q0,qf）。 其中：S是一个有限的状态集合；σ是一个有限的触发集合；δ是（S∪Sλ）×σ到S的映射，即转换函数。Sλ表示对象生成的以前的存在的状态。q0是S的初始状态集合，qf是S的终止状态集合。ti是相关条件或函数调用。 原子对象状态图 与传统的有限状态比较，有三点扩展：①可能有多于一个的初始状态；②一个转换可以是有条件的也可以是无条件的；③有一些转换是交互转换，即一个AOSD中的交互转换可以激发另一个AOSD中的转换。 2、COSD模型 在OSD中相应地用三部分来表示对象的动态行为。 （1）定义的部分：表示在该类中定义的数据成员的状态及转换，由对象的状态定义的数据成员的状态图组成。 （2）聚集的部分：表示对象中的成员对象的状态行为，由构成复杂对象的成员对象的状态图组成。 （3）继承的部分：表示继承的数据成员的状态及转换，由派生出复杂对象的基类的对象的状态图组成。一个复合的OSD记为COSD。 说明：一个AOSD的组合是一个COSD；一个AOSD和COSD组合是一个COSD。 COSD图 对一个自动售货机，假设每次用一元的硬币投入到硬币盒，当收到两个一元币时允许出售货物。包括一些简单的功能，增加一个硬币，返回现有的硬币，将硬币复位到初始状态，以及出售。用三个变量来表示数据：totalQtrs表示硬币总数，CurQtrs表示现在硬币数目，allowVend表示允许售卖。硬币盒的C++源程序代码如下： Class CcoinBox { unsigned totalQtrs; //硬币总数 unsigned CurQtrs; //现在硬币数 unsigned allowVend; //允许售卖 Public: CcoinBox( ) {Reset( );} void AddQtr( ); //增加一个硬币 void ReturnQtrs( ){ CurQtrs=0;}//返回现在的硬币数 unsigned isAllowVend(){return allowVend;}// 返回允许售卖状态 void Reset( ){totalQtrs=0;allowVend=0;CurQtrs=0;}//复位初始状态 void Vend( );//如果允许售卖，更新硬币总数和现在的数量 ｝ void CcoinBox::AddQtr( ) { CurQtrs=CurQtrs+1; //增加一个硬币数 if (CurQtrs>1) allowVend=1; } void CcoinBox::Vend( ) { totalQtrs=totalQtrs+CurQtrs; CurQtrs=0; allowVend=0; } 分析上面的程序段内容，对allowVend 的测试的可能结果，有两个可能的区间或状态：[0,0],[1,M]。其中M是一个特定实现的最大无符号数值。CurQtrs也有同样的两个状态：[0,0],[1,M]。这样对于一个硬币盒共有4个状态：s1，s2，s3，s4。如图6-8所示。 根据OSD模型要求，将上例复合OSD模型成COSD模型。 硬币盒的COSD模型 3、构造对象的状态图 ​ 从C++源程序代码构造OSD模型，从构造出的OSD可以测试发现对象状态行为的错误，这种状态测试方法称之为基于程序或白盒状态测试。 构造对象状态图的步骤如下：①象征性的执行类的每一个成员函数；②根据上面①执行的结果来识别状态；③根据上面①执行的结果来识别转换。 （1）象征性的执行类的每一个成员函数。 硬币盒类的象征性执行结果 路径 执行条件 最终表达式 结果值 Ccoinbox().p0 T(不需要条件即始终满足) 无效 Reset().p0 T 无效 AddQtr().p0 !(CurQtrs>0) 无效 AddQtr().p1 (CurQtrs>0) 无效 ReturnQtrs().p0 T 无效 isAllowVend().p0 T 允许售卖 Vend().p0 isAllowVend()==0 无效 Vend().p1 !(isAllowVend()==0) 无效 （2）根据象征性执行的结果来识别状态 ​ 生成状态的目的是在于解释类中的哪些基于数据成员所取的值的行为。当一个数据成员参与了一个在运行时控制着执行路径的决定（条件）时，它的值会影响到类的行为。这样，可以将数据成员值划分为几个区间，每个区间的数据成员的取值将导致不同的执行路径。 若一个条件语句仅有一个变量X是数据成员，用m和M分别表示数据成员X的值域中的最小值和最大值。数据成员X的状态识别步骤如下： ①检查所有的成员函数的路径条件中以X为条件的语句； ②对①中所识别出来的每一个条件语句，形成X的值域区间，对于区间中的所有取值，条件语句取真值或假值。 如： 条件语句 形成的区间 X>10, X=10 [m, 9], [10, M] X==10, X!=10 [m, 9], [10,10], [11, M] ③由上得到的X的值域上的一个区间集合，然后将所有的区间进行简化成不相交的区间。其步骤如下： a.选择任两个相交的区间A和B b.形成新的区间A-(A∩B)，B-(A∩B)和(A∩B) c.用以上的区间代替A，B d.重复以上的步骤，直到不存在相交的区间为止。最后产生的区间就是状态。 找出硬币盒中数据成员CurQtrs的状态。 从路径条件中得知数据成员CurQtrs上的条件语句是CurQtrs>0和!( CurQtrs>0)；产生的区间是：[m, 0]，[1, M]，而无符号数m=0，所以区间为：[0, 0]，[1, M]。因为区间没有相互覆盖，所以是状态。 （3）根据象征性执行的结果来识别转换 ​ 设状态Si是一个区间[l,u]，如果一个数据成员的值在此区间中，我们就说这个数据成员处于状态Si，用Si (x)来表示表达式(x≥l)∧(x≤u),其中x是一个数据成员或一个变量表达式。PC表示一条路径，E表示一个数据成员d经由一条路径产生的一个终值表达式。 状态转换的构造步骤如下： ①生成一个状态的集合RS，将其初始值置空。 ②将由构造函数产生的终值表达式的状态加入集合RS中，这些状态是初始状态（如果没有构造函数，将所有的状态加入RS中）。 ③选择一个状态Si∈RS把它作为前端状态，若是初始状态，加上导致Si的构造函数的转换，并进行标记。 ④选择定义数据成员d的路径Pk，PCk是路径Pk的路径条件，E是数据成员d的对这条路径的终值表达式。如果Si (d)∧PCk被满足，那么路径将导致从Si开始的一个转移；否则丢失Pk选择下一条路径。 ⑤识别因为路径Pk，从状态Si出发的状转换所产生的所有状态从RS中选择一个状态Si，Sj是从Si开始的，经过路径Pk并满足条件产生转换的一个后继状态，即由于Pk if (Si(d)∧PCk)├Sj(E) 而得到的一个转换的后继状态。也就是说在所有的(Si(d)∧PCk)为真的情况下，Sj(E)必为真。把Sj加到RS中。 ⑥选择所有的数据成员执行④⑤步的状态构造转换。 ⑦将Si从RS中删除。 ⑧从③开始重复到RS为空。 4、基于OSD对象状态测试 （1）测试标准 对象状态标准：若对于OSD中的每一个状态S总有一个测试用例使得对象从初始状态到达状态S，称测试集合Tstate达到了对象状态标准。 对象转换标准：若对于OSD中的每一个转换δ（Si,tj）=Sj总有一个相应的测试用例t1…tj-1,tj,其中t1…tj-1使OSD从初始状态到达源状态Si，然后tj使OSD转换到目标状态Sj，称测试集合Ttran达到了对象转换标准。 条件转换标准：设δ（Si,C:tj）=Sj,是OSD从源状态转换到目的状态，总有一个测试用例得条件C为假，不产生状态转换，称测试集合Tctran达到了条件转换标准。 交互转换标准：对于OSD中的每一个交互转换总有一个测试用例使得这个交互转换得以执行，称测试集合Titran达到了交互转换标准。 （2）测试策略 采用什么样的测试策略使生成的“测试桩”的开销最小？我们采用“自底向上”的策略，其基本思想是：对于每一个复杂的对象Oi构造一个基于它的OSD的“状态结构图”，用于表示对象状态的层次结构。在一棵状态结构树中，根节点对应于对象Oi的OSD，内部节点表示的是聚集的对象和继承的部分COSD，叶子节点代表每一个COSD中的数据属性的AOSD。我们可以使用自底向上的策略对树中的每一个AOSD或COSD生成一个状态单元测试顺序，按照这个顺序就可以对每一个AOSD和COSD执行状态单元测试。 测试驱动的实现与代码的组织 1、测试代码的实现 (1)利用main函数 ​ 利用main函数来调用测试类，并实现测试是测试驱动中最简单的的方式，可以直接将每个测试用例写入到main函数中，然后将测试的结果直接输出到屏幕上。 例6-10 以例6-4自动售货机中的类Class CcoinBox为例，使用main函数方法对类Class CcoinBox进行测试，测试的驱动代码（C++源程序）如下： #include using namespace std; class CcoinBox { unsigned totalQtrs; unsigned CurQtrs; unsigned allowVend; public: CcoinBox(); ~CcoinBox(); void Reset(); void Vend(); void AddQtrs(); void ReturnQtrs(); unsigned isAllowVend(); private: }; unsigned CcoinBox::isAllowVend() { return allowVend; } void CcoinBox::AddQtrs() { CurQtrs = CurQtrs + 1; if (CurQtrs > 1) allowVend += 1;} void CcoinBox::ReturnQtrs() { CurQtrs = 0; allowVend = 0;} void CcoinBox::Vend() { totalQtrs = totalQtrs + CurQtrs; CurQtrs = 0; allowVend = 0;} void CcoinBox::Reset() { totalQtrs = 0; CurQtrs = 0; allowVend = 0;} CcoinBox::CcoinBox() { Reset();} CcoinBox::~CcoinBox(){ } void main() { CcoinBox cb; cb.AddQtrs(); cout （2）嵌入静态方法 ​ 在被测试为中嵌入静态的方法，在静态方法内部实现测试用例执行，然后调用该静态方法，将执行的测试结果输出到屏幕。 例6-11以例6-4自动售货机中的类Class CcoinBox为例，使用静态方法进行测试，C++程序代码如下： #include #include\"SCcoinBox.h\" using namespace std; void SCcoinBox::test() { SCcoinBox cb; cb.AddQtrs(); cout 1) allowVend += 1;*/ allowVend = CurQtrs / 2;//修改后 } void SCcoinBox::ReturnQtrs() { CurQtrs = 0; allowVend = 0; } unsigned SCcoinBox::getCurQtrs() { return CurQtrs; } void SCcoinBox::Vend() { totalQtrs = totalQtrs + 2; CurQtrs -= 2; allowVend--; } void SCcoinBox::Reset() { totalQtrs = 0; CurQtrs = 0; allowVend = 0; } SCcoinBox::SCcoinBox() { Reset(); } SCcoinBox::~SCcoinBox(){ } 面向对象的集成测试和系统测试 面向对象的集成测试 面向对象的集成测试通常需要在整个程序编译完成后进行。 此外，面向对象程序具有动态特性，程序的控制流往往无法确定，因此也只能对整个编译后的程序做基于黑盒子的集成测试。 类簇测试内容 面向对象的集成测试主要是测试类簇。 类簇测试的主要内容如下： （1）关联和聚合关系的测试 （2）继承关系的测试 （3）多态/动态绑定的测试 类集成测试的策略 面向对象软件的类集成测试的两种不同策略。 （1）基于线程的测试：这种测试策略集成对某输入或事件作出回应的相互协作的一组类（即一个线程），分别集成并测试每个线程，同时应用回归测试保证没有产生副作用。 （2）基于使用的测试：这种策略通过测试那些很少使用服务器类的类（称为独立类）而开始构造系统，在独立类测试完成后，再增加使用独立类的类（称为依赖类）进行测试，一直到构成完整的系统。 在面向对象集成测试中应注意几个方面： ①面向对象系统本质上是通过小的、可重用的组件构成，所以，集成测试对于面向对象系统来说更重要。 ②面向对象系统下组件的开发一般更具有并行性，所以，对频繁集成的要求更高。 ③由于并行性的提高，集成测试时需要考虑类的完成顺序，也需要设计驱动器来模拟其他没有完成的类的功能。 类集成测试的测试过程及测试用例的生成 面向对象的集成测试能够检测出相对独立的单元测试无法检测出的哪些类相互作用时才会产生的错误。 基于单元测试对成员函数行为正确性的保证，集成测试只关注系统的结构和内部的相互作用。 面向对象的集成测试可以分成两步进行：先进行静态测试，再进行动态测试。 静态测试 静态测试主要针对程序的结构进行，检测程序结构是否符合设计要求。现在流行的一些测试软件都能提供一种称为“可逆性工程”的功能，即通过源程序得到类关系图和函数功能调用关系图，例如Internationa1d Software Automation公司的Panorama—2for Windows 95、Rational公司的Rose C++ Analyzer等，将“可逆性工程”得到的结果与OOD(面向对象设计)的结果相比较，检测程序结构和实现上是否有缺陷。换句话说，通过这种方法检测OOP(面向对象编程)是否达到了设计要求。 动态测试 动态测试设计测试用例时，通常需要功能调用结构图、类关系图或者实体关系图为参考，确定不需要被重复测试的部分，从而优化测试用例，减少测试工作量，使得进行的测试能够达到一定覆盖标准。测试所要达到的覆盖标准可以是：达到类所有的服务要求或服务提供的一定覆盖率；依据类间传递的消息，达到对所有执行线程的一定覆盖率；达到类的所有状态的一定覆盖率等。同时也可以考虑使用现有的一些测试工具来得到程序代码执行的覆盖率。 具体设计测试用例步骤： ①先选定检测的类，参考OOD分析结果，仔细判断出类的状态和相应的行为，类或成员函数间传递的消息，输入或输出的界定等。 ②确定覆盖标准。 ③利用结构关系图确定待测类的所有关联。 ④根据程序中类的对象构造测试用例，确认使用什么输入激发类的状态、使用类的服务和期望产生什么行为等。 面向对象的系统测试 面向对象的系统测试是对所有类和主程序构成的整个系统进行的整体测试，以验证软件系统的正确性和性能指标，满足规格说明书和任务书所指定的要求。其测试用例可以从对象-行为模型和作为面向对象分析的一部分的事件流图中导出。 面向对象的系统测试应该尽量搭建与用户实际使用环境相同的测试平台，应该保证被测系统的完整性，对临时没有的系统设备部件也应有相应的模拟手段。 面向对象的系统测试的具体测试内容 （1）功能测试 （2）强度测试 （3）性能测试 （4）安全测试 （5）恢复测试 （6）可用性测试 （7）安装/卸载测试等等。 面向对象系统的测试工具 （1）用例 （2）类图 （3）序列图 （4）活动图 （5）状态图 "},"page/1034.html":{"url":"page/1034.html","title":"测试工具","keywords":"","body":"测试工具 "},"page/1035.html":{"url":"page/1035.html","title":"QTR","keywords":"","body":"QTR QTP测试工具 QTP简介 QTP是quicktest Professional的简称，是一种B/S自动测试工具。 QTP提供符合所有主要应用软件环境的功能测试和回归测试的自动化。 采用关键字驱动的理念能够简化测试用例的创建和维护。 QTP的启动 途经一 通过选择菜单“开始/所有程序/HP Software/HP Unified Functional Testing”来启动 途经二 直接双击桌面上的HP Unified Functional Testing快捷图标 QTP的操作步骤 QTP的基本功能 QuickTest Professional 支持功能测试和回归测试自动化，用于每个主要软件应用程序和环境。 它使测试人员能够使用专业的捕获技术直接从应用程序屏幕中捕获流程来构建测试案例。 QTP的基本功能包括两大部分：一部分是提供给初级用户使用的关键字视图；另一部分是提供给熟悉VBScript脚本编写的自动化测试工程师使用的编辑视图，在实际的自动化测试项目中完全可以结合着使用。 录制测试脚本 （1）开始录制。设置成仅录制“Flight”程序后，选择菜单“录制—>录制和运行设置”，或者按快捷键F6，QTP将自动启动指定目录下的“Flight”程序 ​ （2）停止录制。按“停止”按钮停止录制，在关键字视图中，可看到录制的测试操作步骤，每个测试步骤涉及的界面操作都会在Active Screen界面显示出来。 编辑录制测试脚本 调试与运行测试脚本 在编辑好测试脚本后，在运行测试之前，可利用QTP的语法检查功能和脚本调试功能对测试脚本的逻辑进行检查。 具体应用如下： （1）语法检查 选择菜单“设计—>检查语法”，或者按快捷键“Ctrl+F7”对测试脚本进行语法检查，如果语法检查通过，则在“消息”界面（可通过选择菜单“查看—>错误”打开）提示信息“语法有效”，表示语法检查通过。 （2）使用断点 语法检查通过后，可直接运行测试脚本，也可设置断点对脚本进行调试。然后按F5键运行测试脚本，运行过程中将在断点所在的代码行停住。 （3）单步调试 选择菜单“运行—>运行到该步骤”，或者按快捷键“Ctrl+F10”跳到下一行代码，也可以选择“运行—>步入”，或者按快捷键“F11”进入代码行中所调用的函数“Test1”。 （4）调试查看器的使用 选择菜单“查看—>调试查看器”，在文本框输入测试对象属性或变量，可查看其值。 （5）运行整个测试 选择菜单“工具—>选项”，在出现的界面里，在“GUI测试—>测试运行”选项中的“运行模式”，可选择为“普通”或“快速”。 （6）运行部分测试 选择菜单“运行—>运行当前操作”，仅仅运行当前的Action，这种方式有利于单独运行Action，查看单个Action测试执行的情况，有利于定位当前Action运行的问题。 （7）批量运行测试 在QTP中选择菜单“工具—>选项—> GUI测试—>测试运行”，打开界面，确保“允许其他HP产品运行测试和组件”选项被勾选上。 选择“开始—>所有程序—>QuickTest Profession—>Tools—>Test Batch Runner”启动Test Batch Runner。在Test Batch Runner中，选择“批量运行”来批量运行列表中的所有测试脚本。 分析测试结果 自动化测试的最后一个步骤就是运行测试并检查测试结果，这个步骤也是非常重要的，测试员根据测试结果来判断测试是否通过，检查测试脚本是否正确地完成了测试。 图示 QTP的测试使用 测试计划需要确定测试对象、测试组织、测试任务划分、测试失败/通过的标准、挂起恢复的条件、时间安排、资源安排、风险估计和应急计划等，可分为主测试计划、单元测试计划、集成测试计划、系统测试计划和接收测试计划等。 录制测试脚本与执行 1、执行Quick Test并开启一个全新的测试脚本 方法： 启动 QuickTest 并打开新测试 “欢迎使用”窗口单击“空白测试” “工具”-“选项”中打开“插件管理器” 2、开始在 Mercury Tours 网站上录制测试脚本 （1）点击菜单中的 “录制/录制F6”，或单击“录制”按钮 。将打开“录制和运行设置”对话窗口，如图8-16所示。 （2）在“Web”标签页面选择“录制或运行会话开始时打开以下”，并勾选“使用以下方式为运行会话参数化浏览器类型”，然后按确定。 （3）确认“当测试关闭时关闭浏览器”和“不在已经打开的浏览器上录制和运行”处于选定状态。 （4）在“Windows Applications”选项卡中，确认“下面指定的应用程序（B）”处于选定状态，且未列出任何应用程序。 （5）如果选择“在任何打开的浏览器上录制和运行测试（R）”单选按钮，则在录制过程中，QuickTest会记录你对所有的Windows程序所做的操作。如果选择“下面指定的应用程序（B）”单选按钮，则在录制过程中，QuickTest会记录对那些添加到下面“应用程序详细信息”列表框中的应用程序的操作 （6）我们选择第二个单选按钮，因为我们只是对Mercury Tours范例网站进行操作，不涉及Windows应用程序，所有保持列表为空。 （7）点击“确定”按钮，开始进行录制，将自动打开IE浏览器并连接到Mercury Tours范例网站上。 如图8-1所示 3、登录Mercury Tours网站 在“User Name”和“Password”框中，输入在 Mercury Tours 中注册的用户名和密码，单击“Sign-in”，将打开“Flight Finder”网页 如图8-2所示 4、输入航班详细信息 输入以下订票数据： Departing From：New York On：Oct 29 Arriving In：San Francisco Returning：Nov 11 Service Class：Business class 其他字段保留默认值，单击“CONTINUE”，将打开“SELECT FLIGHT”页面。 5、选择飞机航班 可以保留默认值，点击“CONTINUE”按钮，打开“Book a Flight”页面。 6、输入必填字段 在“Passengers”和“Credit Card”部分输入所需信息，在“Billing Address”部分，选择“Ticketless Travel”，在该页底部，单击“SECURE PURCHASE”，将打开“Flight Confirmation”页。 7、完成定制流程 查看订票数据，并选择“BACK TO HOME”，回到Mercury Tours网站首页。 8、停止录制 在 QuickTest 中，单击“测试”工具栏上的“停止” ，停止录制进程。 9、保存测试脚本 选择“文件”>“保存”，或单击“保存”按钮 。将打开“保存”对话框，且显示为“GUITest”文件夹。创建名为Tours 的文件夹，将其选中，然后单击“打开”。 在“文件名”字段中键入 Flight，单击“保存”。测试名 “Flight” 将显示在主 QuickTest 窗口中的标题栏中。 基本测试（同步点、各类检查点） 图示 1、同步点测试 （1）增加QTP预设等待的时间 （2）变更预设等待时间的设定 （3）识别以同步点解决的问题 （4）插入同步点 （5）储存测试脚本 （6）执行测试脚本并查看结果 （7）关闭测试结果和测试脚本 2、检查点测试 （1）标准检查点 （2）页面检查点 （3）文本检查点 （4）表检查点 3、运行检查点并分析测试结果 1、运行检查点 2、分析测试结果 数据驱动测试 建立好测试脚本后，测试人员可能会想要用多组不同的数据去执行测试脚本。为此，测试人员可以将测试脚本转换成数据驱动（Data-Driven）测试脚本，并建立一个数据表提供测试所需要的多组数据。 图示 1、数据驱动测试方法 数据驱动的测试方法要解决的核心问题是把数据从测试脚本中分离出来，从而实现测试脚本参数化。 （1）数据驱动测试的时间 （2）数据驱动测试的步骤 2、参数化测试 通过把测试脚本中固定的值替换成参数的方式来扩展测试脚本，这个过程也叫参数化测试，能有效地提高测试的灵活性。 （1）通过参数化测试来提高测试的灵活性 （2）参数化测试操作步骤 （3）使用随机数来进行参数化 （4）参数化检查点 （5）设置数据表格迭代方式 3、Action测试输入的参数化 在QTP中，对于重复使用的测试用例，可以转换成公共用例，适当参数化后，可被其他测试用例调用。 （1）编辑Action的属性 （2）添加Action的输入参数 （3）调用Action 4、使用环境变量的参数化 在QTP中，除了前面所讲的几种参数化测试的方式外，还可以使用环境变量来进行测试的参数化。使用环境变量来参数化测试步骤如下： （1）定义和设置环境变量； （2）在测试步骤中绑定环境变量值； （3）输出环境变量到XML文件； （4）导入外部环境变量文件。 5、使用数据驱动器来参数化测试 为了简化测试脚本参数化的过程，QTP还提供了名为“数据驱动”的功能，可自动检测脚本中可能需要进行参数化的变量。 （1）数据驱动器的使用方法 （2）数据驱动向导 "},"page/1036.html":{"url":"page/1036.html","title":"LoadRunner","keywords":"","body":"LoadRunner LoadRunner测试工具 LoadRunner简介 性能测试的基本概念 软件的性能是一种非功能性特性，它关注的不是软件是否完成特定的功能，而是软件在完成该功能时展示出来的性能。 其性能指标有：系统响应时间、吞吐量、并发用户数、资源利用率、性能计数器等。 性能测试内容 （1）系统是否很快响应用户的要求？ （2）系统是否能处理预期的用户负载并具有盈余能力？ （3）系统是否能处理业务所需的事务数量？ （4）在预期和非预期的用户负载下，系统是否稳定？ （5）系统是否能确用户在真正使用系统时获得积极的体验? 性能测试目标 （1）客户需求：系统响应时间、支持客户数等； （2）客户的硬件环境：服务器的配置（CPU、内存、磁 盘），客户端的配置； （3）连接数：数据库缓冲池的连接、IE的连接。 1、LoadRunner组成 （1）虚拟用户生成器VuGen(Virtual User Generator)：用来录制操作创建虚拟用户脚本。 （2）压力控制器Controller：执行虚拟脚本产生虚拟用户，对被测试系统发出请求和接收响应，模拟实际的负载。 （3）结果分析器Analysis：通过测试结果的数据，分析测试结果。 （4）Launcher：提供一个集中界面，启动LoadRunner所有的模块。 2、LoadRunner原理 负载性能测试工具的原理通常是通过录制、回放脚本、模拟多用户同时访问被测试系统制造负载，产生并记录各种性能指标，生成分析结果，从而完成性能测试的任务。 3、LoadRunner的特点 （1）能轻松的创建虚拟用户； （2）能创建真实的负载； （3）定位性能问题； （4）分析结果精确，定位问题所在； （5）完整的企业应用环境支持。 4、LoadRunner支持的协议和平台 HP公司的LoadRunner能让企业保护自己的收入来源，无需购置额外硬件而最大限度地利用现有的IT资源，并确保终端用户在应用系统的各个环节中对其测试应用的质量、可靠性和可扩展性都有良好的评价。 LoadRunner的基本功能 1、创建虚拟用户 2、创建负载 3、实时监测 4、分析测试结果 5、重复测试保证系统发布的高性能 6、其他特性 LoadRunner的测试使用 LoadRunner包含很多组件，其中最常用的有VuGen、Controller、Analysis。使用LoadRunner进行负载测试通常由六个阶段组成：计划、脚本创建、场景定义、场景执行、监视场景和结果分析。 1、制定负载测试计划 测试计划是成功的负载测试的关键点之一。任何类型的测试的第一步都是制定比较详细的测试计划。一个比较好的测试计划能够保证LoadRunner完成负载测试的目标。 制定负载测试计划一般情况下需要三个步骤 分析应用程序 （1）确定系统的组成 （2）描述系统配置 （3）分析最普遍的使用方法 确定测试目标 （1）确定性能测试工作的总目标 （2）成员或团队一起审查项目计划 （3）一起检查无力及逻辑结构 （4）询问个别团队成员的问题 计划怎样执行LoadRunner 确定要使用LoadRunner度量哪些性能参数，根据测量结果计算哪些参数，从而可以确定Vusers的活动，最终可以确定哪些是系统的瓶颈等。在这里还要选择测试环境、测试机器的配置情况等。 2、开发测试脚本 在测试环境中，LoadRunner会在物理计算机上用虚拟用户（Vuser）来代替实际用户。Vuser通过以可重复、可预测的方式模拟典型用户的操作，在系统上创建负载。 LoadRunner使用虚拟用户的活动来获得模拟真实用户来操作Web应用程序，而虚拟用户的活动就包含在测试脚本中，所以说测试脚本对于测试来说是非常重要的。 图示 3、创建运行场景 运行场景描述在测试活动中发生的各种事件。一个运行场景包括一个运行虚拟用户活动的Load Generator机器列表、一个测试脚本的列表以及大量的虚拟用户和虚拟用户组。使用Controller来创建运行场景。 "},"page/1037.html":{"url":"page/1037.html","title":"测试管理","keywords":"","body":"软件测试管理 测试计划 软件测试活动在整个软件开发生命周期中可以分为几个子活动，包括软件测试计划、测试用例分析与设计、测试用例实施与管理、测试报告与测试评估等。 测试计划（Testing plan）描述了要进行的测试活动的范围、方法、资源和进度的文档；是对整个信息系统应用软件组装测试和确认测试安排。 它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。测试计划可以有效预防计划的风险，保障计划的顺利实施。 测试计划的目标 测试目标分类 （1）整体目标 整体目标是针对软件项目或一个软件产品来确定的。 （2）阶段性目标 阶段性目标是分别针对单元测试、集成测试、系统测试和验收测试来定义所期望的结果。 （3）特定的任务目标 特定的任务目标是针对某些任务的测试的具体目标。 测试目标的内容 （1）为测试各项活动制定一个现实可行的、综合的计划，包括每项测试活动的对象、范围、方法、进度和预期结果。 （2）为项目实施建立一个组织模型，并定义测试项目中每个角色的责任和工作内容。 （3）开发有效的测试模型，能正确地验证正在开发的软件系统。 （4）确定测试所需要的时间和资源，以保证其可获得性、有效性。 （5）确立每个测试阶段测试完成以及测试成功的标准、要实现的目标。 （6）识别出测试活动中各种风险，并消除可能存在的风险，降低由不可能消除的风险所带来的损失。 测试计划的作用 内部作用 （1）作为测试计划的结果，让相关人员和开发人员来评审。 （2）存储计划执行的细节，让测试人员进行同行评审。 （3）存储计划进度表、测试环境等更多的信息。 外部作用 测试计划的外部作用是为顾客提供一种信心，通常向顾客交代有关测试过程、人员的技能、资源、使用的工具等信息。 测试策略的制定 1、测试策略的内涵 测试策略是在一定的软件测试标准、测试规范的指导下，依据测试项目的特定环境约束而规定的软件测试的原则、方式、方法的集合。 2、测试策略的制定 在制定测试策略过程中，需要考虑用户的特点、系统功能之间的关系、资源配置、上个版本的测试质量和已有的测试经验等各方面的因素。 3、测试策略的优化 测试策略应该尽量简单、清晰。针对不同的测试阶段（单元测试、集成测试、系统测试等）、不同的测试对象或测试目标制定相对应的测试策略。 测试计划的制定 1、搜集测试资料 （1）软件项目背景 包括软件的类别和用途、项目拟投入的资源和时间、项目开发团队和用户相关信息等； （2）软件技术特征 包括软件主要功能、软件所支持的平台、软件开发环境、用户界面、软件所涉及的第三方软件和相关技术等； （3）软件测试背景 包括测试团队背景、拟投入资源和时间、测试环境和测试工具、拟采用缺陷报告和版本控制方法等。 2、制定测试方案 测试方案是软件测试的总体规则，包括测试采取的方针策略、测试环境建立、测试人员分配、测试进度安排等。主要考虑的因素如下： （1）软件因素 考虑软件现在的状况和将来可能的发展。从软件本身的规模、复杂度、缺陷多少和发生频率、将来新增功能等来考虑。 （2）资源因素 考虑能够投入测试的资源。包括硬件、软件、测试团队和拟投入的资金预算等。 （3）风险因素 考虑测试过程中会出现的偏差给软件公司等带来损失的可能性和程度。 3、撰写测试计划文档 测试计划文档是为测试执行、管理、跟踪等提供依据，包括测试目标、测试范围、实施方案、时间和资源安排等内容。 4、评审和更新测试计划 测试计划编写完成后，要对测试计划的正确性、全面性以及可行性等进行评审，评审人员的组成包括软件开发人、营销人员、测试负责人以及其他有关项目负责人。 测试计划模板 - 1　引言 - 1．1编写目的 - 本测试计划的具体编写目的，指出预期的读者范围。 - 1．2背景 - 说明： - a．测试计划所从属的软件系统的名称； - b．该开发项目的历史，列出用户和执行此项目测试的计算中心，说明在开始执行本测试计划之前必须完成的各项工作。 - 1．3定义 - 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 - 1．4参考资料 - 列出要用到的参考资料，如： - a．本项目的经核准的计划任务书或合同、上级机关的批文； - b．属于本项目的其他已发表的文件； - c．本文件中各处引用的文件、资料，包括所要用到的软件开发标准。 列出这些文件的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 - 2　计划 - 2．1软件说明 - 提供一份图表，并逐项说明被测软件的功能、输入和输出等质量指标，作为叙述测试计划的提纲。 - 2．2测试内容 - 列出组装测试和确认测试中的每一项测试内容的名称标识符，这些测试的进度安排以及这些测试的内容和目的，如：模块功能测试、接口正确性测试、数据文件存取的测试、运行时间的测试、设计约束和极限的测试等。 - 2．3测试1（标识符） - 给出这项测试内容的参与单位及被测试的部位。 - 2．3．1进度安排 - 给出对这项测试的进度安排，包括进行测试的日期和工作内容（如：熟悉环境、培训、准备输入数据等）。 - 2．3．2条件 - 陈述本项测试工作对资源的要求，包括： - a．设备：所用到的设备类型、数量和预定使用时间； - b．软件：列出将被用来支持本项测试过程而本身又并不是被测软件的组成部分的软件，如：测试驱动程序、测试监控程序、仿真程序、桩模块等； - c．人员：列出在测试工作期间预期可由用户和开发任务组提供的工作人员的人数。技术水平及有关的预备知识，包括一些特殊要求，如倒班操作和数据键入人员。 - 2．3．3测试资料 - 列出本项测试所需的资料，如： - a．有关本项任务的文件； - b．被测试程序及其所在的媒体； - c．测试的输入和输出举例； - d．有关控制此项测试的方法、过程的图表。 - 2．3．4测试培训 - 说明或引用资料说明为被测软件的使用提供培训的计划。规定培训的内容、受训的人员及从事培训的工作人员。 - 2．4测试2（标识符） - 用与本测试计划2．3条相类似的方式说明用于另一项及其后各项测试内容的测试工作计划。 - 3　测试设计说明 - 3．1测试1（标识符） - 说明对第一项测试内容的测试设计考虑。 - 3．1．1控制 - 说明本测试的控制方式，如：输入是人工、半自动或自动引入，控制操作的顺序以及结果的记录方法。 - 3．1．2输入 - 说明本项测试中所使用的输入数据及选择这些输入数据的策略。 - 3．1．3输出 - 说明预期的输出数据，如：测试结果及可能产生的中间结果或运行信息。 - 3．1．4过程 - 说明完成此项测试的步骤和控制命令，包括测试的准备、初始化、中间步聚和运行结束方式。 - 3．2测试2（标识符） - 用与本测试计划3．l条相类似的方式说明第2项及其后各项测试工作的设计考虑。 - 4　评价准则 - 4．1范围 - 说明所选择的测试用例能够检查的范围及其局限性。 - 4．2数据整理 - 陈述为了把测试数据加工成便于评价的适当形式，使得测试结果可以同已知结果进行比较而要用到的转换处理技术（手工方式或自动方式）；如果是用自动方式整理数据，还要说明为进行处理而要用到的硬件、软件资源。 - 4．3尺度。 - 说明用来判断测试工作是否能通过的评价尺度，如：合理的输出结果的类型、测试输出结果与预期输出之间的容许偏差范围、允许中断或停机的最大次数。 - 4．4测试人员需求 - 4．5其他（仪器、服务器等） - 5．风险评估 - 5．1人力方面 - 5．2时间方面 - 5．3环境方面 - 5．4资源方面 - 5．5部门合作方面 - 6．其他内容 测试范围分析 在确定了测试目标后，为了达到这些目标，要执行相应的测试任务。在执行测试任务过程中，需要分析测试的范围，并根据测试的范围、任务和其他条件，决定测试的环境和测试的工作量。 在进行测试范围分析时，一般先进行功能测试范围的分析，再进行非功能性测试的分析。 1、功能范围分析 功能测试范围分析，主要根据软件产品的规格说明书来完成，并结合功能之间的逻辑关系、用户的使用习惯等，进一步细化功能测试范围。 2、非功能范围分析 对于非功能性测试的分析，可以从性能测试、兼容性测试、适用性测试和安全测试等方面来进行分析。 3、范围管理的内容 通过对测试范围进行分析，确定测试范围管理要描述项目范围。对于要测试的项目，范围管理的内容主要有： （1）理解哪些内容构成产品的发布版本； （2）将发布版本分解为特性； （3）确定特性测试的优先级； （4）确定哪些特征要测试，哪些特性不要测试； （5） 收集数据，准备估计测试资源。 测试工作量估算 当测试范围大致确定了需要测试的内容，这些内容需要在估计步骤中量化。估计大致分为三个阶段：规模估计、工作量估计和进度估计。 这里主要讨论规模与工作量的估算。 1、被测试产品的规模 被测试产品的规模决定需要完成的测试量。被测产品的规模越大，测试的工作量就越大。 常用的度量方法有： （1）代码行数 （2）功能点（FP） （3）屏幕数、报表数或事务数 2、所需的自动化测试范围 当涉及自动化测试时，测试需要增加工作规模。因为自动化测试需要首先进行基本的测试用例设计（运用条件覆盖、边界值分析、等价类划分等），然后通过测试自动化工具的程序设计语言将其脚本化。 3、要测试的平台和互操作环境的数量 如果在多个不同的环境或配置下测试特定产品，测试任务的规模就会增加。随着平台数量或跨不同环境的接触点的增加，测试量几乎呈指数增长。 规模估计可以采用以下任何形式表述： （1）测试用例数 依据测试用例数来估算测试工作量，如：用功能模块所有要执行的测试用例总数，除以每个人日所能执行的测试用例平均数，就得出人日数（工作量）。 （2）测试场景数 依据测试中需要用到的场景来估算工作量，一个场景测试用例仅测试一个场景、事务或业务流程。 （3）要测试的配置数 与测试项目相关的软件与硬件的配置数，如：在多少个相关的软件和硬件配置情况下进行测试等。 4、其它影响因素 （1）生产率数据 生产率是指各种测试活动的完成速度，生产率数据可以从公司内部得到的历史数据。此数据可以进一步分解为每天可以开发的测试用例数量、每天可以运行的测试用例数量、每天可以测试的文档页数等。 （2）重用机会 若在设计测试体系结构时考虑了重用问题，那么覆盖给定的测试规模所需的工作量可以减少。 （3）过程的健壮性 拥有定义良好的过程从长远来说，将会减少完成任何活动所需的工作量。 资源安排 确定测试资源 1、确定人员、责任和培训 （1）测试项目的角色 测试项目的角色包括测试工程师、测试负责人和测试经理等，这些角色要彼此具有互补性。 （2）角色任务分配 软件项目所需的人员在各个阶段是不同的，一个比较健全的测试组员应包括：测试组长、实验室管理员、自动化测试工程师、资深测试工程师和初级测试工程师。 （3）培训 一般来说，除了进行项目的有关产品、业务领域的培训，还要进行测试用例方法、测试自动化原理、测试脚本开发技术和环境设置等方面的培训工作。 培训的内容可以分为纵向和横向两部分。纵向培训是知识传递过程，参与需求和设计评审的测试人员，要对未参与这两方面的测试人员进行培训，将需求和设计评审中遇到的问题、正确的解释等内容给他们说明。横向培训是在不同团队之间进行的，如请开发人员介绍该项目所采用的相关技术、系统架构设计和具体实现的方法等。 2、确定资源需求 （1）运行被测试产品所需的机器配置； （2）如果用到测试自动化工具，所需购买或开发自动化测试工具的开销； （3）相关支持工具的开销，如：编译器、测试数据生成器、配置管理工具等； （4）必须提供的支持软件的不同配置，如：操作系统、第三方软件等； （5）执行机器密集型测试，如：负载测试和性能测试等所需的特殊需求； （6）所有软件的合适数量的使用许可。 除此以外，有一些需要满足的隐含环境需求，包括机房、支持工作人员等。 若对这些资源的估算不足，会严重影响测试工作的进展，会拖延产品的发布时间，还会影响到测试团队的积极性。 测试进度管理 累积缺陷曲线法 基于测试能力处在较高水平的假设，在前期缺陷发现率比较高，随着测试时间、缺陷发现的速率会降低（若前期发现的缺陷，经过程序设计人员的修复），当缺陷越来越难发现时，预示着测试进入尾声。而所有这些变化，都在累积缺陷曲线上表现出来。 所以可以通过累积缺陷曲线来管理测试进度。如图10-1所示： 进度S曲线法 将实际的进度和计划的进度进行比较来发现问题，考察数据是测试用例或测试点的数量，事先将计划的工作进度输入到系统中形成曲线，然后将每日或每周记录的实际进度输入。若发现它们之间的差距较大，就需要进一步调查，找出问题的原因并予以纠正，从而使实际进度与计划进度在总体上保持一致，控制测试的进度。 如图10-2所示： 测试风险的控制 风险管理的要素与方法 1、风险管理要素 风险管理的要素有：确定可能的风险；对风险进行量化；策划如何缓解风险；风险真的出现时的应对措施。 随着一些风险的确定和解决，其他风险又可能出现，因此， 风险管理实际上是一种循环，重复地执行风险确定、风险量化、风险缓解与策划、风险应对。 见图10-3所示。 2、风险确定方法 （1）使用检查单 经过一定时间的测试积累，公司在测试中会有一些新发现，归纳成检查单。 （2）利用公司的历史和指标 如果公司收集并分析各种指标（指标是使用合适的公式或计算方法从度量中导出的数据，有项目指标、进度指标、生产力指标），那么这些信息对确定项目可能出现的风险很有价值。 （3）整个行业的非正式网络 整个行业的非正式网络有助于确定其他公司已经遇到过的风险。 3、风险量化 风险量化是以数字的形式来描述风险。 风险量化有两个要素： （1）风险发生的可能性； （2）风险影响的程度。 低优先级的缺陷可能有很高发生的可能性，但是影响很小。而高优先级缺陷发生的可能性较小，但影响很大。 用一个数字表示这两个要素，通常采用风险指数。风险指数定义为风险可能性和风险影响的乘积。常用金额方式方法表示。 4、风险缓解策划 风险缓解策划，是指如果风险出现采取的应对风险事件的替代策略。 如：缓解风险的一些替代策略是让多个人共享知识和建立公司级过程和标准。为了更好地准备风险带来的影响，最好能有多种缓解策略。 常见的风险与特性 1、不明确定的需求 2、进度依赖性 3、测试时间不足 4、“影响测试继续进行”的缺陷 5、测试人员的技能和测试积极性 6、不能获得测试自动化工具 典型的风险、风险征兆、相关影响和缓解应对计划见表10-1。 测试报告 1、测试事件报告 测试事件报告是在测试周期内遇到缺陷时的沟通。是缺陷库中的一条记录。每个缺陷都有唯一的标识符，用于标识该事件。对于影响大的测度事件，必须在测试总结报告中指出。 2、测试周期报告 测试项目以测试周期为单位实施的，一个测试周期包括在周期内的策划与执行测试用例，每个周期都使用不同的产品版本。每个周期结束时要给出一个测试周期报告，报告主要内容是： （1）本周期完成的活动总结； （2）本周期内发现的缺陷，并对缺陷的严重性和影响进行分类； （3）在缺陷修改前一个周期到当前周期的进展情况； （4）本周期还未修改的严重的缺陷； （5）工作进度、工作量与计划产生的偏差。 3、测试总结报告 对一个测试周期的结果进行总结的报告称为测试总结报告。 在产品验收或发布之前，测试人员需要对软件产品质量有一个完整、准确铁评价，最后提交的测试报告。 测试报告为纠正软件存在的质量问题提供依据，并为软件验收和交付打下基础。 为了完成测试报告，需要对测试过程和测试结果进行分析和评估，确认测试计划是否正确的执行、测试覆盖率是否能够到达预定要求，以及对产品质量是否有信心，最终在测试报告中给出测试和产品质量的结论。 - 软件测试报告（参与模板）如下： - 1引言 - 1.1编写目的 - 1.2项目背景 - 1.3系统简介 - 1.4参考资料 - 1.5术语和缩略语 - 2测试概要 - 2.1测试用例设计 - 2.2测试环境与配置 - 2.2.1功能测试 - 2.2.2性能测试 - 2.3测试方法和工具 - 3测试内容和执行情况 - 3.1项目测试概况 - 3.1.1测试版本 - 3.1.2测试人员组织 - 3.1.3测试时间安排 - 3.2功能测试 - 3.2.1总体KPI - 3.2.2模块1 - 3.2.3模块2 - … - 3.3性能测试 - 3.3.1测试用例 - 3.3.2参数设置 - 3.3.3通信效率 - 3.3.4设备效率 - 3.3.5执行效率 - 3.4可靠性测试 - 3.5安全性测试 - 3.6易用性测试 - 3.7兼容性测试 - 3.8安装和手册测试 - 4覆盖分析 - 4.1需求覆盖 - 4.2测试覆盖 - 5缺陷统计与分析 - 5.1缺陷汇总 - 5.2缺陷分析 - 5.3残留与未解决问题 - 6测试结论与建议 - 6.1测试结论 - 6.2建议 4、产品发布建议 公司根据测试总结报告做出是否发布产品的决策。 在理想情况下，公司希望发布零缺陷的产品。 但现实情况下是不可能的，市场的压力可能导致发布带有缺陷的产品。 如果产品中残留的缺陷的优先级和影响度都很低，或出现这些缺陷的条件不现实，公司可能决定发布带有这些缺陷的产品。 但必须在征求客户支持、开发团队和测试团队之后，公司高层管理才可以作出这样的决定。 测试评估 1、评估测试覆盖率 覆盖率是度量测试完整性的一个手段，是测试有效性的一个度量。测试覆盖是对测试完全程度的评测。测试覆盖是由测试需求和测试用例的覆盖或已执行代码的覆盖表示的。 （1）基于需求的测试覆盖 基于需求的测试覆盖在测试生命周期中要评测多次，并在测试生命周期的里程碑处提供测试覆盖的标识（如已计划的、已实施的、已执行的和成功的测试覆盖）。 （2）基于代码的测试覆盖 基于代码的测试覆盖评测测试过程中已经执行的代码的多少，与之相对的是要执行的剩余代码的多少。 代码覆盖率达到100%也不能代表测试覆盖率很高，如：代码没有实现需求中定义的功能（即这部分代码没写）、或者代码实现的功能与用户的功能不符等，这类问题很难通过代码覆盖率来发现。 覆盖率=（至少被执行一次的item数）/item总数。 2、基于软件缺陷的质量评估 软件质量是反映软件与需求相符程序的指标，而缺陷被认为是软件与需求不一致的某种表现，所以通过对测试过程中所有已发现的缺陷进行评估，可以了解软件的质量情况。 缺陷评估是对测试过程中缺陷达到的比率或发现的比率提供一个软件可靠性指标。 缺陷评测主要有四种度量指标。 （1）缺陷发现率 缺陷发现率是将发现的缺陷数量作为时间的函数来评估。并创建缺陷趋势图或缺陷报告。如图10-4所示。 从图10-4中可知，随着时间和修复缺陷，发现缺陷的数量在减少；而测试成本相应增加。 图10-4 （2）缺陷潜伏期 缺陷潜伏期是一种特殊类型的缺陷分布报告。其报告显示缺陷处于特定状态下的时间长短。是一种特殊类型的缺陷分布度量。 在实际测试工作中，发现缺陷的时间越晚，这个缺陷所带来的损害就越大，修复这个缺陷所耗费的成本也就越多。 （3）缺陷分布（密度） 缺陷分布是指缺陷在软件规模（组件、模块等）上的分布情况，如：每千行代码（KLOC）或每个功能点（或对象点、特征点等）的缺陷数。 缺陷分布报告允许将缺陷计数作为一个或多个缺陷参数的函数来显示。 软件缺陷分布是一种以平均值估算法来计算出软件缺陷分布值。 程序代码常以千行为单位的。见下面公式： 软件缺陷密度=软件缺陷数量/代码行或功能点的数量 （4）整体软件缺陷清除率 为了估算，先引入几个变量。F为描述软件规模用的功能点；D1为在软件开发过程中发现的所有缺陷数；D2为软件发布后发现的缺陷数；D为发现的总缺陷数。其中D=D1+D2。 对于一个软件项目，有如下的计算公式： 质量=D2/F 缺陷注入率=D/F 整体缺陷清除率=D1/D 例子 - 假某一个软件项目，有100功能点，在开发过程中发现15个错误，提交后又发现了5个错误，则知F=100，D1=15，D2=5，D=D1+D2=20。 - 根据公式计算得： - 质量=D2/F=5/100=0.05（5%） - 缺陷注入率=D/F=20/100=0.2（2%） - 整体缺陷清除率=D1/D=15/20=0.75（75%） - 整体缺陷清除率越高，软件产品的质量越好。否则，缺陷清除率越低，质量越差。 测试管理工具 测试管理系统的基本构成 1、测试管理系统交互环境 测试管理系统不仅管理测试过程中的各种测试资源、测试用例、测试环境、测试数据、测试执行结果。而且与缺陷管理、配置管理及其他开发工具等集成在一起，形成一个有机的整体。 这样对软件测试过程中的各个步骤和各个阶段进行了有效的控制和管理，提高了软件开发和测试的管理水平，保证了产品的质量。 如图10-5所示。 2、测试管理系统的基本构成 测试管理系统是测试人员和测试管理人员对软件产品测试过程进行管理的平台，通过测试管理系统提供的功能，测试团队实现测试过程从测试需求管理、测试用例设计到测试执行完整的管理起来。同时，测试管理系统提供测试结果的统计和分析。 测试管理的核心是测试用例和缺陷。所以测试管理系统以测试用例库、缺陷库为核心，覆盖整个测试过程而所需要的组成部分，如图10-6所示。 图10-6 测试管理工具简介 测试管理工具是在指在软件开发过程中，对测试需求、计划、用例和实施过程进行管理、对软件缺陷进行跟踪处理的工具。通过使用测试管理工具，测试人员或开发人员可以更方便地记录和监控每个测试活动、阶段的结果，找出软件的缺陷和错误，记录测试活动中发现的缺陷和改进建议。通过使用测试管理工具，测试用例可以被多个测试活动或阶段复用，可以输出测试分析报告和统计报表。 1、禅道测试管理软件 禅道是第一款国产的优秀开源项目管理软件。它集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，是一款功能完备的项目管理软件，完美地覆盖了项目管理的核心流程。 功能列表如下： （1） 产品管理，（2） 项目管理，（3） 质量管理，（4） 文档管理， （5） 事务管理，（6） 组织管理。（7） 统计功能。（8） 搜索功能。 （9） 灵活的扩展机制，几乎可以对禅道的任何地方进行扩展。 （10） 强大的api机制，方便与其他系统集成。 2、SoapUI开源测试工具 SoapUI 是一个开源测试工具，通过soap/http来检查、调用、实现Web Service的功能/负载/符合性测试。该工具既可作为一个单独的测试软件使用，也可利用插件集成到Eclipse，maven2.X，Netbeans 和intellij中使用。SoapUI pro是SoapUI的商业非开源版本，实现的功能较开源的SoapUI更多。 SoapUI是一个自由和开放源码的跨平台功能测试解决方案。 SoapUI是一个完整的自动化测试解决方案。 3、TestCenter测试管理软件 TestCenter是由上海泽众软件科技有限公司开发的一款测试管理软件。 主要是面向业务流程的、基于B/S体系结构的测试管理工具。其特点是功能完善（覆盖完整的测试过程和测试对象），高度产品化（不需要与测试服务捆绑）；系统稳定；提供多种支持服务方式（可达源代码级）；基于模型的测试用例设计方法，更好的测试覆盖。 功能列表如下： （1）测试任务管理 （2）编制测试计划 （3）安排和执行测试 （4）缺陷跟踪 （5）人工与自动测试相结合 （6）图形化和报表输出 （7）用户权限管理 （8）和其他工具集成 （9）测试资产管理： TestCente自动化测试框架如图10-7所示。 "},"page/1038.html":{"url":"page/1038.html","title":"质量保证","keywords":"","body":"质量保证 软件质量标准 软件质量就是“软件与明确的和隐含的定义的需求相一致的程度”。具体地说，软件质量是软件符合明确叙述的功能和性能需求、文档中明确描述的开发标准、以及所有专业开发的软件都应具有的隐含特征的程度。 影响软件质量的主要因素，可划分为三组，分别反应用户在使用软件产品时的三种观点。包括正确性、健壮性、效率、完整性、可用性、风险（产品运行）；可理解性、可维修性、灵活性、可测试性（产品修改）；可移植性、可再用性、互运行性（产品转移）。 软件质量标准 1、国际标准：国际标准指定和公布供各国参考的标准。 2、国家标准：国家标准是由政府或国家级的机构制定或批准，适用于本国范围的标准。 3、行业标准：行业标准是由一些行业机构、学术团体或国防机构制定，并适用于某个业务领域的标准。 4、企业标准：企业标准是由一些大型企业或公司制定适用本部门的标准。 5、项目规范：项目规范是为一些科研生产项目需要而组织制定的一些具体项目的操作规范，具有专用性。 衡量软件质量常用的指标 1、SLOC（Source Lines of Code，源代码行） 2、 每个代码段/模块/时间段中的bug数 3、代码覆盖率 4、设计/开发约束 5、圈复杂度（Cyclomatic Complexity） 工作现场测试 现场测试 在实际工作中，作为一个测试员，要对找出的软件缺陷负起责任，在整个软件生命周期中跟踪缺陷，说服相关人员使其得以修复，是非常难实行的。因此，最简洁的解决方式是把这些缺陷放在软件缺陷数据库中，期待最终有人引起注意并进行相应的处理，这一点能够做到。 软件质量保证 软件质量保证SQA（Software Quality Assurance）是建立一套有计划，有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目采用。 软件质量保证的目的是使软件过程对于管理人员来说是可见的。它通过对软件产品和活动进行评审和审计来验证软件是合乎标准的。软件质量保证组在项目开始时就一起参与建立计划、标准和过程。这些将使软件项目满足机构方针的要求。 1、软件质量保证基本目标 （1）软件质量保证工作是有计划进行的。 （2）客观地验证软件项目产品和工作是否遵循恰当的标准、步骤和需求。 （3）将软件质量保证工作及结果通知给相关组别和个人。 （4）高级管理层接触到在项目内部不能解决的不符合类问题。 （5）软件质量需要全面的测试工作来保证。 2、全面质量管理（TQM） 包括如下内容： （1）全过程的质量管理：对产品质量产生、形成和实现的各个互相影响的过程控制起来，形成一个综合性质量管理体系，预防为主，防检结合。 （2）全员的质量管理：加强企业员工“质量第一”培训，增强人员责任心，使员工做好本职工作。 （3）全企业的质量管理：组织层面上，质量目标实现依赖于企业各层次（上层、中层和下层）的管理工作，尤以高层起决定性作用。职能层面上，企业的产品的研制、维护和改进质量等所有活动构成一个整体。 （4）多方法的质量管理：根据不同情况、不同因素，采取广泛、灵活的、现代化的多种多样的方式方法进行质量的管理。 其核心理念是关注顾客、全员参与、持续改进等，如图11-1所示。 3、质量保证实现的具体方法 质量保证实现的具体方法如下： （1）定义项目类型和生命周期； （2）建立SQA计划，确定项目审计内容； （3）生成SQA报告； （4）审计SQA报告。 （5）独立汇报； 4、SQA活动通用框架 （1）提出软件质量要求； （2）确定开发方案； （3）阶段评审； （4）测试管理； （5）文档化管理； （6）验证产品与相应文档和标准的一致性； （7）建立测量机制； （8）记录并生成报告。 能力成熟度模型（CMM） CMM的引入和定义 1、CMM的引入 CMM首先是作为一个“评估标准”出现的，用于定义和评价软件公司开发过程的成熟度，提供怎样做才能提高软件质量的指导。它是在美国国防部的指导下，由软件开发团体和软件工程学院（SEI）及Carnegie Mellon大学共同开发的。 CMM关注的软件生产有如下特点： （1）质量重要 （2）规模较大 2、CMM的定义 CMM（Capability Maturity Model for Software）英文缩写为SW-CMM，简称CMM。是对于软件组织在定义、实现、度量、控制和改善其软件过程的进程中各个发展阶段的描述。CMM的核心是把软件开发视为一个过程，并根据这一原则对软件开发和维护进行过程监控和研究，以使其更加科学化、标准化，使企业能够更好地实现商业目标。 软件-->大规模程序 CMM的基本内容 1、CMM的5个等级 CMM明确地定义了5个不同的“成熟度”等级，分别是初始级、可重复级、已定义级、可管理级和优化级。一个组织可按一系列小的改良性步骤向更高的成熟度等级前进。如图11-2所示。 图11-2 CMM的5个等级 2、CMM的18个关键过程域 CMM从等级2到等级5共有18个关键过程域。如图11-3所示。 图11-3 CMM各等级的关键过程域 3、软件能力成熟集成模型CMMI ​ CMMI（Capability Maturity Model for Software Integrated）模型是软件工程模型、系统工程模型、集成化产品模型和过程开发模型以及集成化供应管理模型等多个模型的集合。CMMI过程域的四维表示如表11-1所示。 过程域 成熟度层次 项目计划PP 2 项目监督和控制PMC 2 供应商合同管理SAM 2 集成项目管理IPM 3 风险管理PSKM 3 集成组IT 3 集成供应商管理ISM 3 量化项目管理QPM 4 组织（层）过程定义OPD 3 组织（层）过程焦点OPF 3 组织（层）培训OT 3 组织（层）过程性能OPP 4 组织改革与实施OID 5 需求管理REQM 2 需求开发RD 3 技术解决方案TS 3 产品集成PI 3 验证VER 3 确认VAL 3 配置管理CM 2 过程和产品质量保证PPQA 2 度量和分析MA 2 决策分析和解决方案DAR 3 组织集成环境OEI 3 原因分析和解决方案CAR 5 4、CMM中的质量框架 ​ 软件质量保证SQA是CMM可重复级中6个关键过程域之一，在CMMI中该关键过程域升级为管理中的过程与产品质量保证过程PPQA（Process and Product Quality Assurance），软件质量保证包括评审和审计软件产品和活动，以验证它们是否符合适用的规程和标准，还包括向软件项目和其他有关管理提供评审和审计的结果。 5、CMM/CMMI满足关键过程域要求目标 （1）软件质量保证活动是有计划的；（2）软件产品和活动与适用的标准、规程和需求的符合性要得到客观验证；（3）相关小组和个人要被告知软件质量保证的活动和结果；（4）高级管理者处理在软件项目内部不能解决的不符合问题。 6、CMM流程改进 有如下几点：（1）确定流程改进的总体框架；（2）细化框架内的要求；（3）明确流程改进的度量方法与标准。 ISO9001 ISO9000系列标准的引入 1、ISO9000的引入 ISO9000族标准是国际标准化组织(ISO)于1987年颁布的在全世界范围内通用的关于质量管理和质量保证方面的一系列标准，定义了一套基本达标的实践，帮助公司不断地交付符合客户质量要求的产品。 引入原因： （1）质量管理的理论与实践发展的产物 随着质量管理的理论与实践的发展，许多国家和企业为了保证产品质量，选择和控制供应商，纷纷制定国家或公司标准，对公司内部和供方的质量活动制定质量体系要求，产生了质量保证标准。 （2）国际贸易的迅速发展的产物 随着国际贸易的迅速发展，为了适应产品和资本流动的国际化趋势，寻求消除国际贸易中技术壁垒的措施，ISO/TC176组织各国专家在总结各国质量管理经验的基础上，制定了ISO9000系列国际标准。 2、ISO9001：2015最新版本 国际标准一般都应在5年左右修订，ISO9000标准从1987年首次发布到1994年第一次修订相隔7年，1994版ISO9001标准内容过分趋向于硬件制造业，其他行业应用不便。1994版至今又经过了21年，现行1994版ISO9001标准的20个要素结构模式将相互关联的过程分离，没有体现出现代管理的“过程”概念。 2015年9月份ISO9001:2015正式版发布。ISO9001：2015新版，再也见不到《质量手册》和《程序文件》这类中国人最难以理解的文件形式了，统一用“形成文件的信息”取而代之。通篇也见不到“记录”这两个字眼了，统一用“活动结果的证据”取而代之。 3、ISO9000意义 有两个方面： （1）因其目标在于开发过程，而不是产品。关心的是进行工作的组织方式，而不是工作成果。我们知道，质量是相对的、主观的。公司的目标应该是达到满足客户要求的质量等级，利用满足质量的开发过程有助于实现目标。 （2）ISO900只决定过程的要求是什么，而不管如何达到。具体如何去组织和执行完全取决于组织和执行的各个小组或群体。具有灵活性。 ISO9001简介 1、四个核心标准 （1）ISO9000质量管理体系—— 基础和术语 介绍质量管理方面的基础理论和一些关键的名词解释； （2）ISO9001质量管理体系——要求 从保障顾客利益的角度出发提出一些基本的质量管理要求常用于认证或顾客验厂。 （3）ISO9004质量管理体系——业绩改进指南 围绕经营业绩，兼顾企业、顾客、员工等诸方面利益团队，强调做好每一项工作，为企业提供了改进业绩的参考方法。 （4）ISO19011质量和(或)环境管理体系审核指南 2、ISO9000：2000基本模型 基本模型包括：管理职责、资源管理、过程管理和测量、分析与改进，它们之间的关系以及与客户的关系如图11-3所示。 图11-3 （1）管理职责 最高管理者应通过以下活动，对其建立、实施质量管理体系并持续改进其有效性的承诺提供证据。 （2）资源管理 组织应确定、提供并维护为达到产品符合要求所需的基础设施。适当的教育和培训从事影响产品质量工作的人员，达到能够胜任的技能和经验。 （3）过程管理 组织应按GB/T 19000-2000 质量管理体系标准的要求建立质量管理体系，形成文件，加以实施和保持，并持续改进其有效性。 （4）测量、分析与改进 组织应策划并实施以下方面所需的监视、测量、分析和改进过程。 3、八条原则 （1）以顾客为关注焦点； （2）领导作用； （3）全员参与； （4）过程方法； （5）管理的系统方法； （6）持续改进； （7）基于事实的决策方法； （8）互利的供方关系。 4、八个作用 （1）强化品质管理，提高企业效益。 （2）增强客户信心，扩大市场份额，在产品品质竞争中永远立于不败之地。 （3）提高全员质量意识，改善企业文化。 （4）第三方认证，提供最广泛的认可，节省了第二方审核的精力和费用。 （5）有效地避免产品责任。 （6）获得了国际贸易\"通行证\"，消除了国际贸易壁垒。 （7）法律责任减免：如更容易的许可，更少的检查以及简化的报告要求等。 （8）公众形象及社会关系，为消费者选择提供信心。 5、认证流程 （1）组织自身确定要实施ISO9001认证标准； （2）聘请相应ISO9001辅导老师进行辅导； （3）在辅导老师的协助下，建立ISO9001认证体系，完成文件及记录表单的制作，并对相应人员进行培训； （4）申请ISO9001认证前进行一次内审和管理评审； （5）向ISO9001认证机构提出申请； （6）认证机构对企业进行现场审核； （7）不符合整改并获取证书。 IEEE简介 IEEE概述 IEEE为美国电子电机工程师学会 (Institute of Electrical and Electronic Engineers)，是一个国际性的电子技术与信息科学工程师的协会。建会于1963年1月1日。总部设在美国纽约市。在150多个国家中它拥有300多个地方分会。目前会员数是36万。专业上它有35个专业学会和两个联合会。IEEE发表多种杂志，学报，书籍和每年组织300多次专业会议。IEEE定义的标准在工业界有极大的影响。IEEE的标准制定内容包括电气与电子设备、试验方法、原器件、符号、定义以及测试方法等多个领域。 1、IEEE构成 IEEE现有42个主持标准化工作的专业学会或者委员会。IEEE专门设有IEEE标准协会IEEE-SA（IEEE Standard Association），负责标准化工作。IEEE-SA下设标准局，标准局下又设置两个分委员会，即新标准制定委员会（New Standards Committees）和标准审查委员会（Standards Review Committees）。 IEEE802又称为LMSC（LAN /MAN Standards Committee，局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和MAC层规范，对应OSI参考模型的下两层。 2、标准通过流程 一个IEEE标准通过流程如下：首先从发起人提出标准课题，接着形成由发起人组成的研究组，由此研究组向新标准制定委员会提交项目授权申请书并申请批准；依据该委员会批准的项目授权申请书，组织对此课题有兴趣的专家工作组进行审议，推荐的项目授权申请书原则上应在四年内完成。一旦标准草案起草完成，则先后经工作组、研究组两次无记名投票表决。若两次投票表决同意者均超过75%，则标准草案获得通过，经IEEE-SA最后批准后，便可形成正式标准发布。 IEEE 829 测试文档国际标准 IEEE 829-1998，也被称做829软件测试文档标准，作为一个IEEE的标准，定义了一套文档用于8个已定义的软件测试阶段，每个阶段可能产生它自己单独的文件类型。这个标准定义了文档的格式，但是没有规定它们是否必须全部被应用，也不包括这些文档的测试计划。 1、管理计划的文档 内容包括：测试如何完成（包括SUT的配置）？谁来做测试？将要测试什么？测试将持续多久（虽然根据可以使用的资源的限制而有变化）？测试覆盖度的需求，例如所要求的质量等级。 2、测试设计规格 详细描述测试环境和期望的结果以及测试通过的标准。 3、测试用例规格 定义用于运行于测试设计规格中所述条件的测试数据。 4、测试过程规格 详细描述如何进行每项测试，包括每项预置条件和接下去的步骤。 5、测试项传递报告 报告何时被测的软件组件从一个测试阶段到下一个测试阶段。 6、测试记录 记录运行了哪个测试用例，谁运行的，以什么顺序，以及每个测试项是通过了还是失败了。 7、测试附加报告 详细描述任何失败的测试项，以及实际的与之相对应的期望结果和其他旨在揭示测试为何失败的信息。这份文档之所以被命名为附加报告而不是错误报告，其原因是期望值和实际结果之间由于一些原因可能存在差异，而这并不能认为是系统存在错误。这包括期望值有误、测试被错误地执行，或者对需求的理解存在差异。这个报告由以下所有附加的细节组成，例如实际结果和期望值、何时失败，以及其他有助于解决问题的证据。这个报告还可能包括此附加项对测试所造成的影响的评估。 8、测试摘要报告 一份提供所有直到测试完成都没有被提及的重要信息的管理报告，包括测试效果的评估、被测试软件系统的质量、来自测试附加报告的统计信息。这个报告还包括执行了哪些测试项、花费多少时间，用于改进以后的测试计划。这份最终的报告用于指出被测的软件系统是否与项目管理者所提出的可接受标准所符合。 基于IEEE 829编写文档时可能引用其他文档，包括: IEEE 1008, 单元测试国际标准； IEEE 1012, 软件验证与确认国际标准； IEEE 1028, 软件审查国际标准 ； IEEE 1044, 软件异常分类国际标准； IEEE 1044-1, 软件异常分类指南； IEEE 830, 系统开发需求说明书指南； IEEE 730, 软件质量保证计划标准； IEEE 1061, 软件质量度量及方法的标准； IEEE 12207, 软件生命周期过程及生命周期数据的标准； BS 7925-1, 软件测试术语表； BS 7925-2, 软件构件测试标准。 "},"page/1080.html":{"url":"page/1080.html","title":"测试案例","keywords":"","body":"测试案例 手机软件测试案例 手机基本知识 手机的主要功能 1、 通话功能 2、 消息功能 3 、电话本 4 、增值服务 5 、其他功能 6、 为特定语言定做的功能 7、 附件 8 、数据连通 9 、其它应用程序 手机的基本结构 1、软件结构 手机软件结构如图12-1（a）（b）所示。包括用户界面、手机操作系统和总线设备等。 图12-1 2、硬件结构 手机硬件结构如图12-2所示，主要的组成部分是：RF、UEM、UPP、Flash等。 图12-2 手机软件测试时间 在制定开发计划的同时就要制定测试计划，测试在进行结构设计时就已经进行了。 见图12-3所示。 手机软件测试的流程和方法 手机测试的流程 1、 制定测试计划 2 、测试准备 3 、测试执行 4、 测试评估 5 、文档收集 6 、测试总结报告 手机测试的方法 1 、正确性测试 2、 容错性测试 3、 边界性测试 4、 性能与效率测试 5 、易用性测试 6 、文档测试 手机测试常用的技术 测试相关文档说明 1 、测试计划 2、 测试用例 3、 错误报告 4、 进度报告 5 、总结报告 中国移动智能终端系统软件测试 中国移动智能终端系统简介 1、智能终端的概念 智能终端版CRM/ESOP（客户管理/客户经理工作平台）是CRM/ESOP系统在智能终端上的延伸，其采用无线接入方式，利用智能终端的便携性，拓展了流动式营销服务手段，是对中国移动服务及营销支撑能力的有效提升。（CRM： Customer Relationship Management） 2、智能终端的日常业务 智能终端CRM系统立足于当前的CRM系统，涵盖了业务查询、业务办理以及业务管理三大模块功能，能够支撑普通用户基本的日常业务办理需求。 如图12-4所示。 3、智能终端系统框架 中国移动智能终端的系统框架的逻辑架构，包括：操作系统、智能终端、PC终端等。 如图12-5（a）所示。 中国移动智能终端系统从应用方面来划分模块，由前台、后台、API、业务等构成。 如图12-5（b）所示。 系统架构 1、逻辑架构 智能终端版CRM逻辑架构如图12-5（a）所示 。 （1）终端应用 （2）操作系统 2、功能架构 智能终端版CRM功能分为业务功能和系统功能两部分。 见图12-6所示。 3、网络架构 测试需求分析 1、功能测试 系统功能的测试主要包括：操作员登陆、退出、注销功能和用户身份认证与注销功能。 业务功能界面原型图中用户认证方式以服务密码认证方式为例，输入要素中用户身份认证要素如表12-2所示： 表12-2 各业务功能认证方式由省公司自行配置，本规范建议认证方式如表12-3所示： 2、性能测试 系统的性能测试主要由第三方厂家测试，压力测试、自动化测试等。 这里测试任务，主要是对从发送请求到页面响应的时间比较异常的页面进行跟踪，使用httpwatch软件监控各个请求的jsp页面的响应时间，对于响应时间比较长的，寻找定位问题是否是网络问题或者查询sql不规范导致系统返回信息慢等。 3、链接测试 系统的链接测试，主要是在功能测试的过程中，测试各模块交互界面是否展示异常，是否链接的目标页面不正确等。 测试用例的设计与实现 1、 功能测试 功能测试主要是从软件产品的页面、架构出发，根据系统的需求文档编写测试用例。只考虑需要测试的系统各个模块、各个功能，而不去考虑软件的内部结构及其代码内容。通过评测预期结果和实际结果来验证是否能满足用户提出的要求。 因系统功能包括很多，现举例如下：操作员登录见表12-4和用户身份验证见表12-5。 2、业务查询 因业务查询包括话费余额查询，实时话费查询、账单查询、缴费历史、客户资料查询、积分M值查询、已订购产品查询、免费资源查询、业务展示、PUK码查询、数据流量查询、已办营销活动查询、终端库查询等，现举例如下：话费余额查询见表12-6和帐单查询见表12-7所示。 3、业务办理 对于业务办理，存在入网开户、营业缴费、主体产品变更、附加产品业务变更、梦网业务、号码预约、国际漫游办理、申请停开机、家庭成员管理、账单寄送等业务。现举例如下：入网开户见表12-8和营业缴费见表12-9所示。 撰写测试报告 1、系统功能 （1）操作员登录 【功能定义】 操作员登录是指操作员输入工号、密码等身份验证信息进行登录的功能。登录时使用智能终端设备证书对登录请求进行签名。CRM系统接收到登录请求，首先进行登录签名验签，之后进行操作员身份认证，完成身份验证后再进入智能终端版CRM的功能。 【功能要求】 支持工号、密码、验证码等数据合法性的校验。 读取智能终端的唯一标识（IMEI、MAC），并发送到服务端。 支持根据工号、密码、验证码等进行身份验证。 提供参数配置功能，以选择验证方式，包括短信验证码或图形验证码。 支持密码错误尝试次数限制。 【业务要素】 智能终端唯一标识、智能终端设备证书 图示 2、业务查询 （1）话费余额查询 【业务定义】 话费余额查询是指查询当前用户的帐户余额和实时余额。 【功能要求】 提供查询和展示帐户余额和实时余额的功能。 【业务要素】 输入要素：用户号码、用户身份认证要素。 输出要素：用户号码、用户品牌、实时余额、帐户余额（包括活动名称、返还总额、月返还金额、未返还金额、未返还月份数）。 【业务场景】 用户身份认证成功后，查询并通过界面展示帐户余额和实时余额。 操作结果查看完成后，点击返回按钮可直接返回到导航界面。 图示 3、业务办理 （1）入网开户 【业务定义】 入网开户是指在系统内建立客户档案、开通客户订购的移动服务及建立客户付费信息的过程。 此处指在智能终端版CRM提供入网开户的功能。 【功能要求】 支持客户资料录入的功能。 支持多种号码搜索方式，例如：生日选号、特殊意义数字组合选号、吉祥号码选号、号段选号、品牌选号等。 支持根据号码选择相关的产品。 支持根据号码模式、产品类型等，输入预存话费金额。 支持通过SIM卡写卡器完成写卡的功能。 【业务要素】 查询条件：号码搜索组合查询条件； 查询结果：可用的号码资源； 输入要素：入网号码、身份证件号码，姓名、地址、主体产品、品牌、预存话费金额、ICCID。 输出要素：入网开户结果、入网号码、身份证件号码，姓名、地址、主体产品、品牌、ICCID。 【业务场景】 通过多种号码方式组合查询，获得一组可选号码列表。 浏览待选号码列表，选择号码进行预占操作。 录入身份证件信息或通过二代身份证读卡器读取身份信息。 选择品牌、主体产品、附加产品。 支持选择“台席处理”，结束当前流程，由台席完成后续流程；支持选择“下一步”，由智能终端版6、 输入预存话费金额。 支持选择使用SIM卡写卡器进行写卡完成开户；支持选择手工录入ICCID完成开户。 操作结果查看完成后，点击返回按钮可直接返回到导航界面。 CRM完成开户流程。 图示 测试结果分析 手机软件测试工程师的素质要求 项目领导的任务和能力 1、熟悉本组成员，包括知识、能力、经验、爱好等等； 2、是客户方和本组成员的接口，负责两者之间的沟通； 3、负责分配本组的任务，包括制定计划和日程安排； 4、总结每天的工作结果，若有重要的错误须汇报客户方负责人； 5、新进测试工程师的培训； 6、回答本组内其他测试人员的问题； 7、制作工作进度表，随时报告本组工作进度； 8、监督协调本组成员的工作； 9、收集本组成员的建要求； 10、部分测试工作会议和检查测试条件是否满足控制工作质量。 管理员的工作内容及技能 1、确认错误的真实性； 2、确定错误的优先权和严重级别； 3、遇到问题时需要和客户方负责人商量。 4、每日处理和解答测试人员及工程师的问题。 5、管理员必须具有如下的技能： 比其他人员更熟悉用户界面系统性能评估测试； 更熟悉处理错误的过程； 更熟悉一个错误的生命周期； 更熟悉相关工具。如Lotus Notes协作平台, PC suite（个人电脑套件）, Phoenix连接器等。 测试工程师的职责和素质 1、态度明确、端正，有责任心，严谨的工作作风； 2、良好的沟通和协调能力，积极主动地与别人交流； 3、掌握读取用户界面规范； 4、编写错误报告和设计测试用例； 5、熟练使用相应的软件和工具； 6、执行测试工作； 7、学习数据库里的错误报告（格式、内容和别人的思路）； 8、技术能力 9、 语言水平 "},"page/1999.html":{"url":"page/1999.html","title":"end1081","keywords":"","body":"end1079 "}}